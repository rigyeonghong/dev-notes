💡 면접시, 시스템 요구사항, 제약사항, 성능 병목 지점 이해 필요.
💡 이번 장 통해, 규모 확장성과 관계된 설계 문제를 푸는데 쓰일 유용한 지식 마스터.

#### 단일 서버
![[Pasted image 20240503163317.png]]
#### 데이터베이스
![[Pasted image 20240503163341.png]]

Q. 어떤 데이터베이스를 사용할 것인가?
* 관계형 RDBMS
	* ex. MySQL, 오라클 데이터베이스, PostgreSQL
	* 자료를 열, 칼럼으로 표현
	* 여러 테이블 데이터를 관계에 따라 조인 가능.
* 비관계형 NoSQL
	* ex. CouchDB, Neo4j, Cassandra, HBase, DynamoDB 등
	* 네가지 부류 : 키- 값 저장소, 그래프 저장소, 칼럼 저장소, 문서 저장소
	* 조인 연산 지원하지 않음
	* 좋은 경우
		* 낮은 응답 지연시간 요구될 때
		* 비정형 데이터 다룰 때
		* 데이터를 직렬화하거나 역직렬화 가능하기만 하면 될 때
		* 아주 많은 양의 데이터를 저장해야할 때

#### 수직적 규모 확장 vs 수평적 규모 확장
* 수직적 규모 확장 = 스케일 업 : 서버에 고사양 자원 추가하는 행위
	* ex. 서버로 유입되는 트래픽 양 적을 때
	* 장점) 단순함
	* 단점) 한계 존재
		* 한 대의 서버나 메모리를 무한대로 증설 불가
		* 장애에 대한 자동복구 방안 및 다중화 방안 제시하지 않아 장애 발생시 완전 중단.
* 수평적 규모 확장 = 스케일 아웃 : 더 많은 서버 추가해 성능 개선
	* ex. 대규모 애플리케이션

* 사용자 ↔️ 웹서버 바로 연결시) 사용자 많아지면 웹서버 다운, 응답 속도 느려짐. ➡️부하 분산기/ 로드밸런서 도입

#### 로드밸런서
* 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할.
![[Pasted image 20240503165047.png]]
* 사용자👩🏻‍✈️ ➡️ 로드밸런서의 공개 주소로 접속 : 웹서버가 클라이언트의 접속을 직접 처리하지 않음.
	* 보안 ) 로드밸런서 ➡️ 서버1,2 : 사설 IP 주소로 통신
	* 자동복구 ) 웹 계층의 가용성 향상
		* 서버 1 다운시 모든 트래픽은 서버 2로 전송 : 웹사이트 전체 다운 방지
		* 유입되는 트래픽 가파르게 상승시 우아하게 서버 추가 가능.

#### 데이터베이스 다중화
* 주(master)-부(slave) 관계 설정.
	* 주서버 : 데이터 원본 저장. 쓰기 연산 지원
	* 부서버 : 데이터 사본 저장. 읽기 연산만 지원
		* 대부분 애플리케이션의 읽기 연산 비중 높아 부 데이터베이스 수가 많음.
![[Pasted image 20240503174701.png]]
* 장점
	* 더 나은 성능 : 병렬로 처리되는 질의의 수가 늘어나므로.
	* 안정성 : db 서버 일부 파괴되어도 데이터 보존.
		* ex. 주서버 다운시, 부서버가 주서버됨. 부서버에 없는 데이터는 복구 스크립트 돌려 추가. -> 다중 마스터, 원형 다중화 방식
	* 가용성 : db 서버 일부 장애 발생해도 다른 서버 데이터로 서비스 가능.


* 로드밸런서와 데이터베이스 다중화
![[Pasted image 20240503180522.png]]

➡️ 응답 시간 개선 : 
	1. 캐시 붙이고
	2. 정적 콘텐츠를 CDN(콘텐츠 전송 네트워크)로 옮기면 개선

#### 캐시
* 값비싼 연산 결과 / 자주 참조되는 데이터를 메모리 안에 두고, 뒤이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소
* ex. 웹 페이지 새로고침 할 때마다 표시할 데이터 가져오기 위해 한 번 이상의 db 호출 발생함. 
	* 💡 애플리케이션 성능 : db 얼마나 자주 호출하느냐로 좌우됨. 캐시로 완화 가능.

* 캐시 계층 : 데이터 잠시 보관되는 곳. 
	* db 보다 훨씬 빠름.
	* db 부하 줄여줌.
	* 캐시 계층 규모 독립적 확장 가능.
* 읽기 주도형 캐시 전략
![[Pasted image 20240503183019.png]]
* 캐시할 데이터 종류, 크기, 액세스 패턴에 맞는 캐시 전략 선택하면 됨.

* 캐시 서버 이용
	* 널리 쓰이는 프로그래밍 언어로 API 제공됨

* 캐시 사용시 유의할 점
	* 캐시 사용 바람직한 상황 
		* 데이터 갱신은 자주 일어나지 않으나 참조는 빈번한 경우.
	* 캐시에 둘 데이터 
		* 영속적으로 보관할 데이터는 안됨. 
	* 캐시 데이터 만료 방법 
		* 정책을 마련해두면 좋음. 만료 기한이 짧으면 db 자주 일고, 길면 원본과 차이날 가능성 존재.
	* 일관성 유지 방법 
		* 일관성(데이터 저장소의 원본과 캐시 내 사본 같은지 여부. ) 원본 갱신 연산과 캐시 갱신 연산이 단일 트랜잭션 아니라면, 깨질 수 있음. 
		* 페 이스북에서 내놓은 논문 참조.
	* 장애 대처 방법 
		* 캐시 서버 한대일 경우 단일 장애 지점(특정 지점에서 장애가 전체 시스템 동작 중단시켜버릴 수 있는 경우의 지점)이 되버릴 가능성 존재. ➡️ 캐시 서버 분산.
	* 캐시 메모리 크기
		* 메모리 너무 작으면 캐시의 성능 떨어짐. ➡️ 캐시 메모리 과할당
	* 데이터 방출 정책
		* 캐시가 꽉참면 캐시에 데이터 추가시 기존 데이터 내보내야함. LRU 많이 쓰임. LFU / FIFO 경우에 맞게 적용

#### 콘텐츠 전송 네트워크(CDN)
* 정적 콘텐츠 전송시 쓰이는, 지리적으로 분산된 서버의 네트워크.
	* ex. 이미지, 비디오, css, js 파일 등 캐시 가능.
	* 요청 경로, 질의 문자열, 쿠키, 요청 헤더 등의 정보 기반해 html 캐시하는 것
		
* CDN 사용해 정적 콘텐츠 캐시 방법
![[Pasted image 20240504061338.png]]
* 사용자 ➡️ 웹사이트 방문 ➡️ 사용자에 가까운 CDN 서버가 정적 콘텐츠 전달
* 원본서버가 파일을 CDN 서버에 반환시, 응답 http 헤더에는 해당 파일 얼마나 오래 캐시될 수 있는지 설명하는 TTL(Time-To-Live)값 존재

* CDN 사용시 고려사항
	* 비용 : CDN으로 들어가고 나가는 데이터 전송 양에 따라 요금 냄. 자주 사용되지 않는 콘텐츠는 캐싱하지 말도록 하자
	* 적절한 만료시한 설정 
	* CDN 장애 대처 방안 : CDN 자체가 죽을 경우 웹사이트/애플리케이션이 어떻게 동작해야 하는지 고려. 해당 문제 감지해 원본 서버로부터 직접 콘텐츠 가져가도록 구성.
	* 콘텐츠 무효화 : 만료되지 않은 콘텐츠라도 CDN에서 제거 가능.
		* CDN 서비스 사업자게 제공하는 API 이용해서
		* 콘텐츠의 다른 버전을 서비스하도록 오브젝트 버저닝 이용. 콘텐츠의 새로운 버전 지정하기 위해서는 URL 마지막에 버전 번호를 인자로 전달.

* CDN 과 캐시 추가된 설계 : 캐시가 DB 부하 줄여줌.
![[Pasted image 20240504064357.png]]



#### 무상태(stateless) 웹 계층
* 웹 계층을 수평적으로 확장하는 방법
* 상태 정보 (사용자 세션 데이터)를 웹 계층에서 제거해야함. ➡️ 관계형 DB, NoSQL 에 저장하고 필요할 때 가져옴

	* 상태 정보 의존적 아키텍처 : 클라이언트 정보 유지해 요청들 사이에 공유되도록.
		![[Pasted image 20240504084938.png]]
		* 문제) 같은 클라이언트로부터의 요청은 항상 같은 서버로 전송되야하는 것. ➡️ 로드밸런서 : 고정 세션으로 기능 지원하나 부담. 서버 추가 제거도 까다롭고 서버 장애 처리도 복잡.
	* 무상태 아키텍처
		![[Pasted image 20240504085238.png]]
		* 상태 정보는 웹 서버로부터 물리적 분리
		* 장점) 단순, 안정, 규모 확장에 쉬움

* 무상태 웹 계층 갖도록 기존 설계 변경
![[Pasted image 20240504085328.png]]
* 공유 저장소 : RDBMS, 캐시시스템, NoSQL 일 수 있음.
	* NoSQL 사용시 규모 확장 간편.
* 장점) 상태 정보가 웹서버들로부터 제거되어, 트래픽 양에 따라 자동 규모 확장 가능!

#### 데이터 센터
![[Pasted image 20240504085732.png]]
* 지리적 라우팅 : 장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내.
	* gedDNS : 사용자 위치에 따라 도메인 이름을 어떤 IP 주소로 변환할지 결정할 수 있도록 해주는 DNS 서비스.
* 장애 발생시) 장애 없는 데이터 센터로 전송.

* 위와 같은 다중 데이터센터 아키텍처를 만들기 위해 해결해야 하는 기술적 난제.
	* 트래픽 우회
		* 올바른 데이터 센터로 트래픽 보내는 효과적 방법 찾기. GeoDNS는 가장 가까운 데이터센터로 트래픽 보내게 해줌.
	* 데이터 동기화
		* 데이터 센터마다 별도 DB 사용시, 장애가 자동 복구되어 트래픽이 다른 DB로 우회되어도 해당 데이터센터에는 찾는 데이터 존재 안할 수 있음. ➡️ 데이터를 여러 데이터센터에 걸쳐 다중화
	* 테스트와 배포
		* 여러 데이터 센터 사용하도록 시스템 구성된 상황) 웹사이트/애플리케이션을 여러 위치에서 테스트해보는 것이 중요. 자동화된 배포 도구는 모든 데이터 센터에 동일 서비스 설치되도록 하는데 중요한 역할!

* 시스템을 더 큰 규모로 확장하기 위해서는 시스템의 컴포넌트 분리해, 각기 독립적으로 확장되도록 해야함. ➡️ 메시지 큐

#### 메시지 큐
* 메시지의 무손실을 보장하는 비동기 통신 지원 컴포넌트.
* 메시지의 버퍼 역할하여, 비동기적으로 전송.
* 메시지 큐의 기본 아키텍처
	![[Pasted image 20240504091313.png]]

* 장점 
	* 서버 간 결합 느슨해져, 규모 확장성 보장되는 안정적 애플리케이션 구성에 좋음.
	* 생산자는 소비자 프로세스 다운되어도 메시지 발행 가능. 반대도 가능.
* ex. 이미지의 크로핑, 샤프닝, 블러링 지원하는 사진 보정 애플리케이션.
	* 보정 : 시간 오래 걸리는 프로세스라 비동기 처리하면 편리.
* 큐의 크기 커지면 더 많은 작업 프로세스 추가해서 처리 시간 줄일 수 있으나, 큐가 비어있다면 작업 프로세스 줄일 수 있음.

#### 로그, 메트릭 그리고 자동화
* 규모가 커지면 로그, 메트릭, 자동화에 투자 필수.
1. 로그
	* 에러 로그 모니터링이 중요. 시스템의 오류와 문제를 보다쉽게 찾아내기 때문. 서버 단위 모니터링도 가능하나, 로그를 단일 서비스로 모아주는 도구 활용하면 더 편리하게 조회 가능.
2. 메트릭
	* 메트릭 잘 수집하면 사업 현황에 관한 유용한 정보 얻고, 시스템 현 상태 파악 가능.
	* 호스트 단위 메트릭 : cpu, 메모리, 디스크 I/O 관련
	* 종합 메트릭 : db 계층, 캐시 계층 성능
	* 핵심 비즈니스 메트릭 : 일별 능동 사용자, 수익, 재방문
3. 자동화
	* 지속적 통합 도와주는 도구 : 개발자 만드는 코드가 어떤 검증 절차 자동으로 거치하도록 가능.
	* 빌드, 테스트, 배포 자동화로 개발 생산성 향상

#### 메시지 큐, 로그, 메트릭, 자동화 등을 반영해 수정한 설계안
![[Pasted image 20240504092052.png]]


#### 데이터베이스의 규모 확장
* 저장할 데이터 많으면 DB 부하도 증가하므로

1. 수직적 확장 (스케일 업)
	* 기존 서버에 더 많거나 고성능의 자원 증설.
	* 한계
		* db 서버 hw에는 한계 존재하므로 무한 증설 불가. 
		* SPOF로 인한 위험성 큼
		* 비용이 많이 듬

2. 수평적 확장 (샤딩)
	* 더 많은 서버 추가.
	* 샤딩 : 대규모 DB를 샤드라는 작은 단위로 분할하는 기술.
		* 모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이 중복은 없다.
		![[Pasted image 20240504092606.png]]
	* 샤딩 키(파티션 키) 정하는 방법의 중요성 : 데이터를 고르게 분할하도록.

	* 샤딩 도입시 문제
		* 데이터의 재 샤딩 ➡️ 안
		* 정 해시
			* 데이터 너무 많아 하나의 샤드로는 감당 불가시
			* 샤드 간 데이터 분포 균등치 못해 특정 샤드 공간 소모가 빠를 때 
		* 유명인사 문제 (핫스팟 키 문제)
			* 특정 샤드에 질의 집중되 서버에 과부하 걸리는 문제 ➡️ 더 잘게 쪼개서 할당해야함
		* 조인과 비정규화
			* 여러 샤드에 걸친 데이터를 조인하기 힘듦 ➡️ DB 비정규화해 하나의 테이블에서 질의 수행되도록.
			* **비정규화** : 정규화된 db schema에서 일부로 중복 허용/ 테이블 합치는 작업 
				![[Pasted image 20240504093555.png]]

* DB 샤딩 적용 아키텍처
![[Pasted image 20240504093043.png]]

#### 백만 사용자, 그리고 그 이상
* 수백만 사용자 이상 지원시 새로운 전략 도입 필요.
	ex. 시스템 최적화 및 더 작은 단위의 서비스로 분할
	



#### ✨ 다중 마스터, 원형 다중화 방식
- Multi-master replication: https://en.wikipedia.org/wiki/Multi-master_replication
- NDB Cluster Replication: Multi-Master and Circular Replication: https:// dev.mysql.com/doc/refman/5.7len/mysql-cluster-replication-multi-master.html

##### Multi-master replication(다중 마스터 복제)
* 2개 이상의 DB 서버가 동일한 데이터 세트의 읽기, 쓰기 작업 모두 처리하도록 하는 구성.
* 각 서버는 데이터 변경 사항을 동시에 받아들이고 업데이트
* 장점
	* 고가용성 : 하나의 서버(노드) 실패해도 계속 작동
	* 부하 분산 : 단일 서버에 대한 부하 감소
	* 지리적 분산
* 단점
	* 복잡성
	* 데이터 무결성 : 동시 여러 노드 데이터 변경될 수 있기에 충돌 발생 가능성 높음.
	* nw 오버헤드 : 모든 노드가 서로를 업데이트 해야해서 트래픽 증가
* 예시
	* 주로 대규모 웹 애플리케이션, 글로벌 서비스, 금융 시스템 등
![[Pasted image 20240504095704.png]]

####  원형 다중화 방식



#### ✨캐시 관련
* Caching Strategies and How to Choose the Right One: https://codeahoy. com/2017/08/11/caching-strategies-and-how-to-choose-the-right-one/
* R. Nishtala, "Facebook, Scaling Memcache at," 10th USENIX Symposium no Networked Systems Design and Implementation (NSDI '13).

#### ✨ 동적 콘텐츠 캐싱


#### ✨ 장애 상황시 데이터 동기화 ex. 넷플릭스
Active-Active for Multi-Regional Resiliency: https:/netflixtechblog.com/active-active-for-multi-regional-resiliency-c4771966856


#### ✨ 메시지 큐



# 2. 계략적 규모 측정

💡 많이 출제되는 개략적 규모 추정 문제는 QPS, 최대QPS, 저장소 요구량, 캐시 요구량, 서버 수 등을 추정하는 것

* 메모리는 빠르지만 디스크는 아직도 느리다.
* 디스크 탐색(seek)은 가능한 피하라.
* 단순한 압축 알고리즘은 빠르다.
* 데이터를 인터넷으로 전송하기 전에 가능하면 압축하라.
* 데이터센터는 보통 여러지역(region)에 분산되어있고, 센터들간에 데이터를 주고 받는데는 시간이 걸린다.

#### 가용성
* 고가용성 : 시스템이 오랜시간 지속적으로 중단없이 운영될 수 있는 능력