# 15. 디자인 패턴과 프레임워크
* 요약 : 설계를 재사용하는 디자인 패턴과 설계와 코드를 재사용하는 프레임 워크 살펴봄.
         프레임워크의 기반 이루는 제어 역전 원칙 설명.

# 부록 C. 동적인 협력, 정적인 코드
* 요약 : 정적인 코드가 동적 협력 이끄는 것이 아닌 동적 협력 기반으로 정적 코드 구성해야함.
         객체지향 설계에 있어 정적 개념과 관계 중요하다는 사람에게 신선한 관점 제시.


* 전략 패턴에 대해 설명하시오
  인터페이스를 하나 추가하고, 해당 인터페이스를 구체화하는 클래스 만든 후 객체의 생성자나 setter 메서드에 할당해 런타임 시에 알고리즘 바꿀 수 있게 하는 것.

  정적 모델은 동적 모델에 의해 주도돼야함
정적 모델은 객체 사이 협력 기반
-> 중요 생각 요소 : 변경 (단순/결합도 낮고/중복 없는 코드)
중복 코드 : 많을 수록 여러곳 한꺼번에 수정. 버그 발생확률 증가 -> 중복코드 제거 / 새로운 추상화(상속) (합성 믹스인)

◦ 중복 코드 제거하려할 때 어떤 방법 사용하실 거 같으세요? 이유는?

⭐️행동이 코드 결정 : 상속계층 구성 방식
변경 고려 : 합성 사용 (중복 줄여)
도메인 모댈은 힌트 역할 : 궁극적 목적은 동작하는 sw
⭐️중요한 것은 객체 협력 지원하는 코드 구조 (객체의 책임)

타입 오브젝트 패턴 : 어떤 인스턴스가 다른 인스턴스 타입 표현하는 방법 ex. 몬스터 클래스

P516
◦ 객체지향적 설계하실 때 올바른 챡임읓 옿바른 객체레할당해 유연한 협력 구축하시려할텐데, 어떤 키워드를 가지고 중점적으로 설계하실지
캡슐화, 크기, 의존성, 유연성, 성능, 확장 가능성, 재서용성 등의 트레드오프

P519
◦ 전략패턴 목적 : 알고리즘 변경을 캡슐화, 이를 구현하려 객체합성 사용(추상 클래스나 인터페이스 사용해 변경 캡슐화)

테플릿 메소ㅡ 패턴 : 캡슐화하려 상속 사용(추상 메서드로 변경 캡슐화 : 자식에서 오버라이드
-> 런타임 알고리즘 교체 불가능
상대적으로 복잡도 낮출 수 있음

데코레이터 패턴 : 행동 동적 추가 : 객체 행동 결합위해 객체 합성 사용. 선택적 행동개수와 순서 변경을 캡슐화 가능
콤포싯 패턴 : 개별 객체와 복합 객체라는 객체의 수 관련 변경을 캡슐화하는 목적.
Leaf / compisite/ component

프레임워크 : 시스템 일부 구현해놓응 재사용 가능한 설계
= 코드와 설계 재사용
핵심 : 인터페이스 / 추상 클래스 같은 추상화(일관성있는 협력 만드는 핵심 재료)
(최대한 의존성은 추상화 향하도럭 : 의존성 역전)
훌륭한 객체지향 설계 = 의종성 역전된 설계
= 프레임유ㅓ쿠의 기본 설뎨 메커니즘

프레임워크에서 일반 해결책만 제공허고 어플에 따라 갈라질 특정 동작은 비워둠 = 훅(프레임워크 코드에서 호출하는 프레임워크 특정 부분)제어가프레임워크로
