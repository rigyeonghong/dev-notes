* 요약 : 의존성 개념 및 느슨한 결합도 위한 설계 방법.

* 잘 설계된 객체지향 애플리케이션 : 작고 응집도 높은 객체들로 구성되어 협력.
* 작고 응집도 높은 객체 : 책임 명확 + 한 가지 일만 잘함

* 협력 위해 의존성 필요. but 과한 의존성은 수정 어렵게함.
## 핵심 : 협력에 필요한 의존성 유지하며, 변경 방해 의존성 제거하는 것


# 1. 의존성 이해하기
* 의존성은 실행 시점, 구현 시점에 다른 의미.
* 의존성은 단방향.
* 다른 객체 필요로 하는 경우, 의존성 존재한다함.
* 의존성은 변경에 의한 전파 가능성 암시

* `의존성 전이` 
	* 실제로 전이 될지는 변경의 방향과 캡슐화 정도에 따라 다름.
	* 직접 의존성 : 코드에 드러남
	* 간접 의존성 : 직접 관계는 아니나 의존성 전이에 의해 영향 전파됨. 코드에 명시적 드러나지 x

* 유연하고 재사용 가능한 코드 설계 위해 `런타임 의존성과 컴파일타임 의존성 다르게 만들어야함` 
	= 추상 클래스 의존
	* `런타임 의존성` : 실행되는 시점의 객체간 의존성
	* `컴파일타임 의존성` : 작성된 코드 혹은 컴파일 시점의 클래스간 
	ex. movie ---> DiscountPolicy (AmountDiscountPolicy vs PercentDiscountPolicy)

* `컨텍스트 독립성` : 클래스가 사용될 특정 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용 수월.

* `의존성 해결 `: 컴파일 타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것
	* 생성자 통해
	* 객체 생성 후 setter 메서드 통해
		* 장점 : 실행 시점에 의존 대상 변경 가능으로 설계 유연
		* 단점 : 객체 생성하고 의존 대상 설정 전 객체 상태 불안정
			ex. NullPointException 예외 발생 가능성
	* 메서드 실행 시 인자 이용해
		* 메서드 실행시마다 의존 관계 달라져야 할 때


# 2. 유연한 설계
* 바람직한 의존성은 재사용성될 가능성을 열어놓은 것
	* 두 요소 사이 의존성이 바람직하다면 느슨한 결합도
	* `의존성` : 두 요소 사이 관계 유무
	* `결합도` : 두 요소 사이 의존성 정도

* 결합도의 정도 : 자신이 의존하는 다른 요소에 대해 알고 있는 정보 양으로 결정.
* 느슨한 결합도 위해서는 협력 대상에 대해 필요 정보외 감춰야함!! => `추상화`

* 추상화에 의존하라
	* 결합도 느슨 정도
		구체 클래스 의존성 < 추상 클래스 의존성 < ➡️ 인터페이스 의존성

* 의존성은 명시적으로 표현되야함
	* 의존성이 명시적이지 않으면 클래스를 다른 컨텍스트에서 재사용 위해 내부 구현 직접 변경 필요..
	* `명시적 의존성` : 의존성이 퍼블릭 인터페이스에 노출. 
		* ➡️ ex. `setter 메서드, 생성자, 메서드 인자`
	* `숨겨진 의존성` : 의존성이 퍼블릭 인터페이스에 표현되지 x

* new 는 해로움
	* 구체 클래스 이름 직접 기술로 의존성 증가
	* 어떤 인자로 생성자 호출해야 하는지도 알아야해서 지식 양 즈악로 결합도 증가
	* ➡️ 인스턴스 생성 로직과 사용 로직 분리.

* 가끔은 생성해도 무방
	* 클래스 안에서 객체 인스턴스 직접 생성이 유용한 경우
		* 주로 협력하는 기본 객체 설정하고픈 경우 ➡️ 기본 생성자 + 인스턴스 인자로 받는 생성자 체이닝

* 표준 클래스 의존은 해롭지 않음
	* ex. ArrayList

* 컨텍스트 확장하기
	* 1. 할인 혜택 제공 x 경우 ➡️ 할인 정책 한 종류로 추가
	* 2. 중복 적용 가능한 경우 ➡️ 마찬가지

> 유연하고 재사용 가능한 설계는 how 나열하지 않고, 객체들의 조합으로 무엇(what)을 하는지 표현하는 클래스로 구성.
> 이를 위해 의존성 관리 필요.