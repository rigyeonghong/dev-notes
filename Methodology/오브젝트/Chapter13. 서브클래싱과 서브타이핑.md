* 요약 : 슈퍼타입과 서브타입 설명 및 타입 계층 만족시키기 위해 적용할 수 있는 설계 원칙 설명. 
	올바른 타입 계층 구성 위해 클라이언트 관점에서 슈퍼타입과 서브타입 사이 행동 호환되도록 만들어야함.


### 서브클래싱과 서브타이핑
* 서브클래싱 : 구현상속 : 코드 재사용 목적으로 상속 사용. 자식 클래스 인스턴스가 부모 클래스 인스턴스 대체 불가.
* 서브타이핑 : 인터페이스 상속 : 타입 계층 구성 위해 상속 사용. 자식이 부모 인스턴스 대체 가능. ➡️ 행동 호환성 만족 & 부모 클래스에 대한 자식 클래스의 대체 가능성.

> 슈퍼타입 인스턴스 요구하는 모든 곳에서 서브타입 인스턴스 대신 사용 위해 만족해야 하는 최소한 조건 : 서브타입의 퍼블릭 인터페이스가 슈퍼타입에서 정의한 퍼블릭 인터페이스와 동일하거나 더 많은 오퍼레이션 포함해야함.

# 4. 리스코프 치환 원칙 ➡️ 확장성 좋음
> 프로그램에서 A가 B로 치환될 때, 프로그램 동작이 변하지 않으면 B는 A의 서브타입이다.

* 위반하는 고전 사례 : 정사각형 직사각형 ➡️ 서브 클래싱 관계.
  직사각형은 정사각형으로 변환 불가.
  적사각형은 직사각형의 구현을 재사용할 뿐.

* 상속 관계 두 클래스 사이 관계를 클라이언트와 떨어트려 놓고 판단말라!! ➡️ 대체 가능성 결정하는 건 클라이언트. 클라이언트 관점에서 is-a일 때만 참이다.

* 잠재적 개방-폐쇄 원칙.

### 타입 계층과 리스코프 치환 원칙
* 클래스 상속은 타입 계층 구현 여러 방법 중 1

# 5. 계약에 의한 설계와 서브타이핑
* 계약에 의한 설계
  - 메서드 실행 위한 사전조건 ex. null 이 아닐때
  - 메서드 실행 후 보장해야하는 사후 조건 ex. 반환값 null 아니어야함
  - 실행 전 후 인스턴스 만족시켜야하는 클래스 불변식

> 서브타입이 리스코프 치환 원칙 만족 위해 : 클라이언트와 슈퍼타입 간 체결된 계약 준수 필요.

> 서브타입에 더 강력한 사전조건 정의 불가. 약하거나 같으면 가능.
> 같거나 강한 사후조건 가능. 약한 사후조건 불가.

---
Q. 상속을 사용하는 목적
- 코드 재사용 / 타입 계층 구현.
	* 어떤 조건을 만족시켜야 타입 계층 위해 올바르게 상속한건지 예시들어 설명.
          - 상속관계가 is-a 관계를 모델링하고, 클래이언트 입장에서 부모 클래스 타입으로 자식 클래스 사용해도 무방할 때.(행동 호환) EX. 펭귄과 새

Q. isp = 인터페이스 분리 원칙에 대해 설명해주세요.
- 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙.

	* 리스코프치환 원칙이란
          - 서브타입은 그것의 기반 타입에 대해 대체 가능 해야 하며, 클라이언트는 차이점을 인식하지 못한채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다. = 행동 호환
   
Q. 서브클래싱과 서브타이핑에 대해 설명해주세요.

* 개방 폐쇄OCP(확장열림수정막힘) / 의존성 역전DIP(상위에 의존)
