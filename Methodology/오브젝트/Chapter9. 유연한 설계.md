* 요약 : 8장 기법 원칙 관점 정리 : 추상 개념과 장황한 메커니즘 또렷하게, 설계 논의시 사용할 수 잇는 공통 어휘 익힘.

  # 1. 개방-폐쇄 원칙
  * 확장에 열려 있고, 수정에 닫혀 있어야 한다.

    * 확장 : 요구사항 변경시, 새 동작 추가로 기능 확장.
    * 수정 : 코드 수정않고 동작 추가 및 변경 가능.
   
    ### 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라
    * 컴파일 타임 의존성을 런타임 의존성으로 대체 : 실행시 객체 행동 확장
    ### 추상화가 핵심이다
    * 개방-폐쇄 원칙의 핵심 : 추상화에 의존.
       - 추상화 : 확장 가능케
       - 추상화에 대한 의존 : 폐쇄 가능케 

# 2. 생성 사용 분리
* 결합도가 높아질수록 개방-폐쇄 원칙 따르는 구조 설계의 어려움..
  - ex. 객체 생성도 메세지 전송도 해야하는데,, 어카지,,
> SW 시스템은 시작 단계(응용 프로그램 객체 제작하고 의존성 연결하는)와 실행 단계(시작 단계 이후 이어지는)를 분리해야 한다.

* 간편 방법 : 객체 생성 책임을 클라이언트로 옮기기.
![image](https://github.com/user-attachments/assets/69afed6a-8311-4d97-a0d3-b91c814bbf87)

### FACTORY 추가하기
* client도 특정 컨텍스트에 묶이지 않기 바랄 때 : 생성 + 사용 책임 함께 지닐 때
* 객체 생성 관련 책임 전담 객체(FACTORY) 추가하고 Client가 해당 객체 사용하도록.

### 순수 가공물에게 책임 할당하기
* GRASP 패턴 : 책임 수행하는데 필요한 정보 가장 많이 알고 있는 INFORMATION EXPERT에게 책임 할당하는 것.
  - FACTORY는 도메인 모델에 해당하지 않음..
  - 설계자 편의 위해 임의로 만들어낸 PURE FABRICATION(순수 가공물)에 할당한 것.

# 3. 의존성 주입
* 사용하는 객체가 아닌 외부의 독립 객체가 인스턴스 생성 후 이를 전달해서 의존성 해결하는 방법
* 컴파일타임 의존성과 런타임 의존성 차이 해소하기 위한 메커니즘 포괄.
* 생성자 주입, setter 주입, 메서드 주입

### 숨겨진 의존성은 나쁘다
* SERVICE LOCATOR 패턴 : 의존성 해결할 객체들 보관하는 저장소로, 객체가 직접 SERVICE LOCATOR에 의존성 해결해줄 것을 요청.
* 단점 : 의존성을 감춘다.. = 퍼블릭 인터페이스 어디에도 의존성에 대한 정보가 표시돼 있지 않음. ➡️ 런타임에 문제 발견.. & 단위 테스트 어려움

> 캡슐화는 코드를 읽고 이해하는 행위와 관련 있다. 
> 클래스의 퍼블릭 인터페이스만으로 사용 방법 이해할 수 있는 코드가 캡슐화 관점에서 훌륭한 코드

> 접근해야 할 객체 있다면 전역 메커니즘 대신, 필요한 객체 인수로 넘겨줄 수 없는지부터 생각해보기. 쉽고 결합 명확히 보임!
> 그러나, 로그나 메모리 관리 같은 정보가 모듈의 공개 API 에 포함되면 안됨.

# 4. 의존성 역전 원칙(DIP : Dependency Inversion Principle)
### 추상화와 의존성 역전
* 상위 수준 클래스가 하위 수준 클래스 의존시 재사용 문제 존재 ➡️ 둘 다 추상화에 의존.

### 의존성 역전 원칙과 패키지
* 인터페이스 소유권에도 적용 : SEPERATED INTERFACE 패턴
  - 포함하는 패키지 안의 어떤 클래스 수정되도 패키지 전체 배포되야함.
  - ex. Movie 재사용 위해 필요한 DiscountPolicy만 같은 패키지로 모으고, AmountDiscountPolicy/PercentDiscountPolicy는 별도 패키지 위치.

# 5. 유연성에 대한 조언
### 유연한 설계는 유연성이 필요할 때만 옳다
* 설계의 미덕은 단순함과 명확함! <-> 유연한 설계(복잡한 설계)
* Q 어떤 변경에 대비 위해 설계 복잡하게 만들었나? 정말 유연성이 필요한가?
  - 변경은 예상이 아닌 현실이어야함.
 
### 협력과 책임이 중요하다
* 설계 유연 : 협력에 참여하는 객체가 다른 객체에게 어떤 `메세지`를 전송하는지
* 객체 생성 방법에 대한 결정은 모든 책임 자리잡은 후 마지막!

> 의존성 관리하는 이유 : 역할, 책임, 협력 관점에서 설계가 유연하고 재사용 가능해야 하기 때문. 하므로 역할, 책임, 협력에 먼저 집중.


  
