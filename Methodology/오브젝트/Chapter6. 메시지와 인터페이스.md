* 요약 : 훌륭한 퍼블릭 인터페이스 작성위해 따라야하는 설계원칙 소개.

## 수신하는 메시지 -> 객체의 퍼블릭 인터페이스 구성 -> 객체 품질 결정

## 1. 협력과 메시지
#### 클라이언트- 서버 모델
* 두 객체간 `협력` 관계 예시에 적합
* 협력 가능하게 해주는 `메시지`

### 메시지와 메서드
* 동적 의존관계 : 두 객체 사이 결합도 낮춤으로, 유연 + 확장 가능

#### 퍼블릭 인터페이스와 오퍼레이션 & 시그니처
* 퍼블릭 인터페이스 : 객체가 외부에 공개하는 메시지 집합
* 오퍼레이션 : 퍼블릭 인터페이스에 포함된 메시지
* 메서드 : 실제 실행되는 코드
* 시그니처 : 오퍼레이션의 이름 + 파라미터 목록. ex. isSatisfied(param)


## 2. 인터페이스와 설계 품질
* 좋은 인터페이스 : 최소한 + 추상적
* how to : 책임 주도 설계 방법 : 객체보다 `메시지` 먼저 선택

* 퍼블릭 인터페이스 품질에 영향 미치는 원칙
	* 디미터 법칙
		* 객체 내부 구조에 강결합되지 않게 협력 경로 제안. 오직 인접한 이웃과만 말하라!
			* Method 인자로 전달된 클래스
			* Class의 인스턴스 변수의 클래스
		* 디미터 법칙은 `캡슐화`를 지키기 위해 접근해야하는 요소 제한한 것.
	* 묻지 말고 시켜라
		* 객체의 상태 묻지 말고 원하는 것을 시켜라
		* ex. 인터페이스는 객체가 어떻게 하는지가 아닌, `무엇을` 하는지 서술
	* 의도를 드러내는 인터페이스
		* 무엇을 하는지 의도를 드러내는 것
		* ex. isSatisfiedBy()   vs isSatisfiedByPeriod()
		* ex. audience.setTicket() -> audience.sellTo()
	* 명령-쿼리 분리
		* 명령 : 객체 상태 수정 오퍼레이션
		* 쿼리 : 객체 정보 반환 오퍼레이션
		* 상태 변경하는 명령은 반환값 가질 수 없다!! 정보 반환 쿼리는 상태 변경 불가!! => 참조 투명성!!
			* 참조 투명성 : 어떤 표현식 e가 있을 때 모든 e를 e의 값으로 바꿔도 결과가 달라지지 않는 것
			* 불변성은 부수효과 발생 방지하고, 참조 투명성 만족시킴.

# 3. 원칙의 함정
* 설계는 트레이드오프의 산물
* 언제 원칙이 유용하고 유용하지 않은지 판단 능력 필요.
	* ex. 결합도와 응집도의 충돌

* 책임에 초점 맞춰라^^
	* 메시지 먼저 선택 -> 처리할 객체 선택 : 디미터 법칙 & 묻지말고 시켜라 & 의도 드러내는 인터페이스 준수
	* 객체 구현 이전에 협력에 초점 : 명령과 쿼리 분리 준수