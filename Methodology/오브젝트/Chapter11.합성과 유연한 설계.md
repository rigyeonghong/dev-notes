* 요약 : 코드 재사용 위해 상속 대신 합성 소개. 느슨한 결합도로 설계 유연 가능. 추가로 객체 행동 유연하게 조합하는 믹스인.

> 코드 재사용 위해선 객체 합성이 클래스 상속보다 좋은 방법.
- 상속 & 합성 : 코드 재사용 기법
  - 상속 : 부모 클래스 코드 재사용. 컴파일 타임 의존성. is-a(a는 b의 일종이).
    - 부모 클래스 내부 구현 상세히 알아야 해서 결합도 높음.
  - 합성 : 전체를 표현하는 객체가 부분 표현 객체 포함해 부분 객체의 코드 재사용. 런타임 의존성. has-a(a는 b를 가지고 있다).
    - 구현에 의존하지 않음. 퍼블릭 인터페이스에 의존. 내부 구현 변경되도 영향 최소화.
    - 객체 퍼블릭 인터페이스 재사용.
   
# 1. 상속을 합성으로 변경하기
* 상속 문제
  - 불필요한 인터페이스 상속
  - 메서드 오버라이딩 오작용
  - 부모 클래스와 자식 클래스의 동시 수정
 
#### 불필요한 인터페이스 상속 문제 해결
ex. Properties 와 Stack
* 상속 관계 제거, Hashtable을 Properties 의 인스턴스 변수로 포함

#### 메서드 오버라이딩 오작용 문제 해결
ex. InstrumentedHashSet 와 HashSet
* set 인터페이스 실체화, HashSet 인스턴스 합성
* 포워딩 : 기존 클래스의 인터페이스 그대로 외부에 제공 + 구현에 대한 결합 없이 일부 작동 방식 변경.

#### 부모 클래스와 자식 클래스의 동시 수정 문제 해결
ex. PersonalPlaylist
* 해결 되진 않으나, 향후 playlist 내부 구현 변경해도 파급효과를 PersonalPlaylist 내부로 캡슐화.


# 2. 상속으로 인한 조합의 폭발적 증가
* 문제
  - 하나의 기능 추가/수정 위해 불필요한 많은 수의 클래스 추가/수정
  - 단일 상속 지원하는 언어에서 상속으로 중복 코드 양 증가
 
#### 상속으로 구현
* 모든 자식 클래스들이 추상 메서드 오버리딩해야 하는 문제

> 추상 메서드와 훅 메서드
> 개방-폐쇄 원칙 만족 설계 : 부모 클래스에 추상 메서드 추가하고 부모 클래스의 다른 메서드 안에서 호출
> 단점 : 모든 자식 클래스가 오버라이딩해야함.

* 상속 남용으로 클래스 폭발 문제!!

# 3. 합성 관계로 변경하기
* 컴파일타임 의존성과 런타임 의존성 거리가 멀수록 설계 복잡도 상승하나, 너무 변경에 따른 혼란이 크다면 선택. 원래 설계보다 단순해지기도 함.

> 객체 합성이 클래스 상속보다 더 좋은 방법
> 상속의 강결합,, (구현 상속 / 인터페이스 상속)


# 4. 믹스인 = 추상 서브 클래스 = 쌓을 수 있는 변
* 상속과 합성의 특성 모두 보유
* 믹스인 : 객체 생성시 코드 일부를 클래스 안에 섞어 재사용하는 기법
* 컴파일 시점에 필요한 코드 조각 조합.

* 전체 요금제 클래스를 확장 가능한 추상 클래스로 구현.
* 스칼라 trait : 믹스인 하는 시점에 가서 대상 결정. = super 참조가 가리키는 대상이 실행 시점에 결정.
* 스칼라 with : 믹스인 : 트레이트 조합.

> this는 동적 결정 / super는 컴파일 시점 결정

![image](https://github.com/user-attachments/assets/b22f9b78-483a-4dbb-9cc1-19bd512738b4)
* 클래스 자신, 조상 클래스, 트레이트를 일렬로 나열(오른쪽부터 나). 믹스인되기 전까지 위치 결정되지 않음.
* 객체 인스턴스 실행시 선형화된 구조에서 해당 메서드 존재할 때까지 위로 탐색하며 호출.
