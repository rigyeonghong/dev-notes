* 요약 : 객체 지향 핵심 메커니즘 중 하나. 그 중 서브타입 다형성 중점. 
	객체지향 시스템이 런타임에 메시지 처리할 적절한 메서드 찾기 위해 사용하는 동적 메서드 탐색 기법 설명.

* 상속의 목적
  - 코드 재사용 x
  - 타입 계층 구조화 (다형성 기반) = 다형성을 위한 서브타입 계층 구축
 
* 상속의 개요
  - 객체지향 패러다임 주목받을 시절, 타입 계층 & 다형성 구현 유일 방법
  - 최근에는 상속 외 다형성 구현할 다양한 방법 제공으로 중요성 낮아짐.
 
* 다형성 : 런타임에 메시지 처리 위해 적합한 메서드 동적 탐색하는 과정 통해 구현됨.
  - 상속 : 탐색 경로를 클래스 계층 형태로 구현하기 위한 방법.


# 1. 다형성
* 정의
  - 하나의 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력.
  - 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법.
 
* 오버로딩 다형성
  ```java
  public class Money {
	public Money plus(Money amount) {...}
  	public Money plus(long amount) {...}
  }
  ```

* 강제 다형성
  - 언어가 지원하는 자동 타입 변환으로 동일 연산자를 다양한 타입에서 사용 가능한 방식
  - ex. 이항 연산자인 '+'
    피연산자 정수일 때 덧셈 / 정수와 문자열일 때 연결 연산자

* 매개변수 다형성
  - 재네릭 프로그래밍 관련. 인스턴스 변수/메서드 매개변수 타입을 임의 타입으로 선언 후 사용 시점에 구체적 타입 지정 방식.
  - ex. 자바의 List 인터페이스 : 컬렉션에 보관할 요소 타입 T : 실제 인스턴스 생성 시점에 구체 타입으로 지정 가능.
 
* 포함 다형성 (서브타입 다형성)
  - 널리 알려진 다형성. 메시지 동일해도 수신한 객체의 타입에 따라 실제 수행되는 행동 달라지는 능력
  - ex. movie -> discountPolicy.calculateDiscountAmount() : discountPloicy에 따라 달라짐
  - 일반적 구현 ) 상속 : 자식 클래스에서 부모 클래스 오버라이딩. 클라이언트는 부모 클래스 참조


## 이번 장 핵심 : 포함 다형성 관점) 런타임에 상속 계층 안에서 적절한 메서드 선택 방법. 상속 관계 기준으로 설명 > 다양한 방법에 공통 적용 개념

# 2. 상속의 양면성
> 상속의 목적은 다형성 가능하게 하는 타입 계층 구축.

* 상속 메커니즘 개념
  - 업캐스팅
  - 동적 메서드 탐색
  - 동적 바인딩
  - self 참조
  - super 참조


### 상속

![image](https://github.com/user-attachments/assets/6ef07597-b141-47c6-86ba-29c7341ec7b2)


### 업캐스팅과 동적 바인딩
- 업캐스팅 : 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스 할당하는 것.
- 동적 바인딩 : 선언된 변수 타입 아닌 메시지 수신하는 객체 타입에 따라 실행되는 메서드 결정하는 것.
> 개방-폐쇄 원칙 : 업캐스팅과 동적 바인딩이 코드 변경 않고 기능 추가해주기에 관련.

ㅊ* 요약 : 객체 지향 핵심 메커니즘 중 하나. 그 중 서브타입 다형성 중점. 
	객체지향 시스템이 런타임에 메시지 처리할 적절한 메서드 찾기 위해 사용하는 동적 메서드 탐색 기법 설명.

* 상속의 목적
  - 코드 재사용 x
  - 타입 계층 구조화 (다형성 기반) = 다형성을 위한 서브타입 계층 구축
 
* 상속의 개요
  - 객체지향 패러다임 주목받을 시절, 타입 계층 & 다형성 구현 유일 방법
  - 최근에는 상속 외 다형성 구현할 다양한 방법 제공으로 중요성 낮아짐.
 
* 다형성 : 런타임에 메시지 처리 위해 적합한 메서드 동적 탐색하는 과정 통해 구현됨.
  - 상속 : 탐색 경로를 클래스 계층 형태로 구현하기 위한 방법.


# 1. 다형성
* 정의
  - 하나의 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력.
  - 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법.
 
* 오버로딩 다형성
  ```java
  public class Money {
	public Money plus(Money amount) {...}
  	public Money plus(long amount) {...}
  }
  ```

* 강제 다형성
  - 언어가 지원하는 자동 타입 변환으로 동일 연산자를 다양한 타입에서 사용 가능한 방식
  - ex. 이항 연산자인 '+'
    피연산자 정수일 때 덧셈 / 정수와 문자열일 때 연결 연산자

* 매개변수 다형성
  - 재네릭 프로그래밍 관련. 인스턴스 변수/메서드 매개변수 타입을 임의 타입으로 선언 후 사용 시점에 구체적 타입 지정 방식.
  - ex. 자바의 List 인터페이스 : 컬렉션에 보관할 요소 타입 T : 실제 인스턴스 생성 시점에 구체 타입으로 지정 가능.
 
* 포함 다형성 (서브타입 다형성)
  - 널리 알려진 다형성. 메시지 동일해도 수신한 객체의 타입에 따라 실제 수행되는 행동 달라지는 능력
  - ex. movie -> discountPolicy.calculateDiscountAmount() : discountPloicy에 따라 달라짐
  - 일반적 구현 ) 상속 : 자식 클래스에서 부모 클래스 오버라이딩. 클라이언트는 부모 클래스 참조


## 이번 장 핵심 : 포함 다형성 관점) 런타임에 상속 계층 안에서 적절한 메서드 선택 방법. 상속 관계 기준으로 설명 > 다양한 방법에 공통 적용 개념

# 2. 상속의 양면성
> 상속의 목적은 다형성 가능하게 하는 타입 계층 구축.

* 상속 메커니즘 개념
  - 업캐스팅
  - 동적 메서드 탐색
  - 동적 바인딩
  - self 참조
  - super 참조


### 상속

![image](https://github.com/user-attachments/assets/6ef07597-b141-47c6-86ba-29c7341ec7b2)


# 3. 업캐스팅과 동적 바인딩
- 업캐스팅 : 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스 할당하는 것.
- 동적 바인딩 : 선언된 변수 타입 아닌 메시지 수신하는 객체 타입에 따라 실행되는 메서드 결정하는 것.
> 개방-폐쇄 원칙 : 업캐스팅과 동적 바인딩이 코드 변경 않고 기능 추가해주기에 관련.

# 4. 동적 메서드 탐색과 다형성
* 동적 메서드 탐색
  - 자동적 메시지 위임
  - 동적인 문맥
    - ex. self 전송은 자식 클래스에서 부모 클래스로 진해오디는 동적 메서드 탐색 경로를 다시 self 참조가 가리키는 원래 자식 클래스로 이동시킴. -> 극단 어려운 코드 가능..
  - 정적 타입 언어와 이해할 수 없는 메시지 -> ex. java > compile error
  - 동적 타입 언어와 이해할 수 없는 메시지 -> method_missing 에 응답할 수 있는 메서드 구현 가능
 
  - self 대 super
    - super
      - 메시지 전송하는 클래스의 부모 클래스에서 시작 -> 더 상위 조상 클래스 메서드에 메시지 전송.
      - 컴파일 시점 결정.
    - self
      - 메시지 수신 객체 클래스에 따라 메서드 탐색 시작 위치 동적 결정.
      - 실행 시점 동적 결정
     
# 5. 상속 대 위임
* 위임과 self 참조
  - 위임 : 자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리를 요청하는 것.
           항상 self 참조를 인자로 전달.
           클래스 이용한 상속 관계를 객체 사이의 합성 관계(ex. Person 객체는 WalkingStrategy 객체를 포함)로 대체해 다형성 구현.
  
  - 포워딩 : 객체가 다른 객체에게 요청을 처리할 때 인자로 self 참조 전달하지 않고, 단순히 코드 재사용 목적.

* 프로토타입 기반의 객체지향 언어
  - 프로토타입 기반 객체지향 언어 : 클래스 대신 객체를 복사하여 새로운 객체를 생성하는 방식으로 동작하는 객체지향 프로그래밍(OOP) 패러다임을 따르는 언어.
    상속을 구현하는 유일 방법은 객체 사이 위임 이용.

> 상속이 클래스 사이 정적 관계로 구현 아님
> 클래스 기반 객체지향 언어도 클래스 제약 벗어나기 위해 위임 메커니즘 사용 가능.

