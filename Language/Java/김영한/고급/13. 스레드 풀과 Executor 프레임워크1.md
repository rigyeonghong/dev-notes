# 스레드 직접 사용시 문제점
1. 스레드 생성 비용으로 인한 성능 문제
  - 메모리 할당
    : 자신만의 호출 스택위해 메모리 할당. 1M 이상.
  - 운영체제 자원 사용
    : 스레드 생성은 os 커널 수준에서, system call 통해 처리. ➡️ cpu, 메모리 리소스 소모.
  - 운영체제 스케줄러 설정
    : 관리 및 실행 순서 조정. 스케줄링 알고리즘에 따라 추가 오버헤드.

> 스레드 생성은 상대적으로 무거움. 작업 실행보다 생성이 더 오래 걸림!! ➡️ 재사용 하자!!

2. 스레드 관리 문제
  - cpu, 메모리 한정 : 시스템 버틸 수 있는 최대 스레드 수까지 스레드 생성 및 관리 필요.

3. Runnable 인터페이스의 불편함
  - 반환 값 없음 : run() 메서드는 반환 값 없음.
  - 예외 처리 : 체크예외 던질 수 없음.

➡️ 반환 값 받고, 예외 처리할 수 있으면 좋겠다!!

➡️ 스레드 풀 : 이미 만들어진 스레드 조회하ㅊ# 스레드 직접 사용시 문제점
1. 스레드 생성 비용으로 인한 성능 문제
  - 메모리 할당
    : 자신만의 호출 스택위해 메모리 할당. 1M 이상.
  - 운영체제 자원 사용
    : 스레드 생성은 os 커널 수준에서, system call 통해 처리. ➡️ cpu, 메모리 리소스 소모.
  - 운영체제 스케줄러 설정
    : 관리 및 실행 순서 조정. 스케줄링 알고리즘에 따라 추가 오버헤드.

> 스레드 생성은 상대적으로 무거움. 작업 실행보다 생성이 더 오래 걸림!! ➡️ 재사용 하자!!

2. 스레드 관리 문제
  - cpu, 메모리 한정 : 시스템 버틸 수 있는 최대 스레드 수까지 스레드 생성 및 관리 필요.

3. Runnable 인터페이스의 불편함
  - 반환 값 없음 : run() 메서드는 반환 값 없음.
  - 예외 처리 : 체크예외 던질 수 없음.

➡️ 반환 값 받고, 예외 처리할 수 있으면 좋겠다!!

➡️ 스레드 풀 : 이미 만들어진 스레드 조회하ㅊ
