# 11. 다형성2
* 타입이 다르기 때문에 함수 중복 제거 시도가 안돼..
	➡️ Dog, cat, caw 가 모두 같은 타입 사용하고, 자신의 메서드 호출한다면?
	
```java
Dog dog = new Dog();
Cat cat = new Cat();

soundAnimal(dog);
soundAnimal(cat);

private static void soundAnimal(Animal animal) {
	animal.sound();
}
```
![[Pasted image 20240422153309.png]]
* **다형적 참조 : 부모는 자식을 담을 수 있음.**
* **메서드 오버라이딩 : 각 인스턴스의 메서드 호출 가능.**


* 배열과 for문으로 중복 제거
```java
Dog dog = new Dog();
Cat cat = new Cat();
Animal[] animalArr = {dog, cat};

for (Animal animal : animalArr) {
	System.out.println("동물 소리 테스트 시작");
	animal.sound();
	System.out.println("동물 소리 테스트 끝");
}
```

```java
Animal[] animalArr = {new Dog(), new Cat()};

for (Animal animal : animalArr) {
	soundAnimal(animal);
}

// 동물 추가되어도 변하지 않는 부분 
private static void soundAnimal(Animal animal){
	System.out.println("동물 소리 테스트 시작");
	animal.sound();
	System.out.println("동물 소리 테스트 끝");
}
```

* 변하는 부분 최소화하는 것이 좋은 코드. ➡️ 변하는 부분, 변하지 않는 부분 잘 분리하는게 좋음👍🏻
	ex. 하나의 변경사항이 발생되었을 때 어디까지 코드를 변경해야하나. 샷건 🔫

* Animal 클래스 생성할 수 있는 문제.
* Animal 클래스를 상속 받는 곳에서 sound() 메서드 오버라이딩 안할 가능성의 문제.

#### 추상 클래스1
* 추상 클래스 : 부모 클래스는 제공하나, 실제 생성되면 안되는 클래스. 실체인 인스턴스가 존재하지 않고 상속 목적으로 사용. ex. 동물
```java
abstract class AbstractAnimal {...}
```

* 추상 메서드 : 부모 클래스를 상속받는 자식 클래스가 **반드시 오버라이딩** 받아야 하는 메서드. 실체 존재하지 않고, 메서드 바디 없음.
	* 추상 메서드가 하나라도 있으면 무조건 추상 클래스.
	* 오버라이딩 하지 않으면 자식도 추상 클래스 되어야함.
```java
public abstract void sound();
```

#### 추상 클래스2
* 순수 추상 클래스 : 모든 메서드가 추상 메서드인 추상 클래스
![[Pasted image 20240422155303.png]]
* 단지 다형성 위한 부모 타입으로써 껍데기 역할 제공.
* 어떤 규격을 지켜 구현 위한 것. 마치 인터페이스. ex. usb 인터페이스.
* ~~순수 추상 클래스~~ = 인터페이스

#### 인터페이스
```java
public interface InterfaceAnimal {
	int MY_PI = 3.14;
	
	void sound();
	void move();
}
```
* 인터페이스의 모든 메서드는 public, abstract 이고 생략 가능.
* 다중 구현(다중 상속) 지원.
* 인터페이스에 멤버 변수 포함 가능. public, static, final 이 모두 포함되었다고 간주.

* 인터페이스 사용해야 하는 이유
	* 반드시 구현하라는 제약 전달
	* 다중 구현 가능

#### 인터페이스 - 다중 구현
* 다중 상속 안되는데, 다중 구현 허용한 이유는 인터페이스는 추상 메서드로 이뤄져있기 때문. (자식에서 메서드 구현하기 때문) ↔️ 다이아몬드 문제 (어떤 한 부모를 선택해야하는)
![[Pasted image 20240422160956.png]]


# 12.  다형성과 설계

#### 객체 지향 프로그래밍
* 유연하고 변경 용이 - 다형성
	ex. 운전자 역할 - 자동차 역할
			구현:	k3, 아반떼, 테슬라

#### 역할과 구현 분리 ➡️ 자바 언어의 다형성 활용해 가능
* 장점
	* 단순
	* 클라이언트는 역할(인터페이스)만 알면 되고, 내부 구조 몰라도 됨.
	* 클라이언트는 내부 구조 변경해도 영향 받지 않기에 실행 시점에 유연하게 인스턴스 변경 가능. 

#### 역할과 구현 분리의 한계 존재
* 인터페이스(역할) 자체 변경할 수도 있음 ➡️ 인터페이스 안정적으로 잘 설계하는게 중요

#### 정리
* 디자인 패턴 대부분 다형성 활용
* 제어의 역전, DI 결국 다형성 활용하는 것
	* IOC (제어의 역전) : 프로그램 흐름에 대한 제어권이 사용자 코드에서 프레임워크/라이브러리로 넘어가는 것. ex. 프레임워크에서 흐름 자동 관리. 더 넓은 개념으로 프레임워크가 라이프사이클 및 의존성 관리.
	* DI (의존성 주입): 객체의 생성과 그에 대한 의존성 설정을 외부에서 처리. ex. 실행시간에 인터페이스의 구체적인 구현을 주입할 수 있는 기능. IOC 구현 방법 중 하나로 객체가 필요로 하는 다른 객체들을 외부에서 주입받는 방식. 

#### 다형성 - 역할과 구현 예제
![[Pasted image 20240425175812.png]]

* 위 문제에서 다형성 활용시, 역할/구현 분리해서 클라이언트 코드 변경없이 구현 객체 변경 가능.
	* 클라이언트(driver) :  Car 역할에만 의존하지 구현에 의존하지 않도록.
	* 의존한다 : 클래스에서 다른 클래스를 알고 있다.

#### OCP 원칙
* Open for extension : 새 기능 추가 및 변경시, 확장 가능해야함.
* Closed for modification : 기존 코드는 수정되지 않아야함.
➡️ 기존 코드 수정없이 새 기능 추가할 수 있다.
ex. 새로운 차량 추가시 driver 코드에는 변경 없는 것.
	- o : 새로운 car 추가
	- c : 클라이언트 코드인 driver 
##### ≒ 전략 패턴
* 클라이언트 코드 변경없이 쉽게 변경.


# 다음으로
1. 클래스와 데이터 : 구조체 개념 / 참조형
2. 기본형과 참조형 : 자바 개발자 거름망
6. 접근 제어자 : 감추고 클라이언트 필요한 거 열어줌
9. 상속 : 부모 기능 물려받음
10. 다형성 : 객체 지향 꽃. 다형적 참조 & 메소드 오버라이딩


#### in 스터디
* emailService
* 객체지향이란 다형성을 이용해 전체 시스템에서 - 클린 코드
* 의존성 역전 원칙 DIP
	* 고수준 모듈은 저수준 모듈에 의존하지 않고 추상화에 의존. 어떠한 무기도 사용할 수 있다는 절대적 제어 권한.
		![[Pasted image 20240425231728.png]]
		* 상위 계층(정책 ex. 기획팀에서 전달)이 하위 계층(세부 사항)에 의존하는 전통 의존관계 역전.

* 의존성 주입 DI
	* 객체 생성과 의존성 설정을 외부에서 관리. 객체 자체는 자신의 의존 객체를 직접 생성하거나 관리 필요 없도록.
	* ![[Pasted image 20240425234005.png]]
* 제어의 역전 LoC
	* 프로그램 흐름 제어를 사용자 코드에서 프레임워크로 옮기는 것. 개발자는 비즈니스로직에 집중, 프레임워크가 프로그램의 흐름과 생명주기 관리를 자동처리.
		![[Pasted image 20240425233705.png]]

* 리스코프 치환 원칙 위반 사례 ) 정사각형-직사각형 문제를 불변객체로도 해결 가능.
	* 정사각형이 직사각형이 상속받아도 너비, 높이를 불변객체로 해놓으면 좋다.
* 자바8 이후 인터페이스 default 메서드를 주의해서 써야함.
	* default 메서드 사용시 인터페이스도 메서드 구현 가능. 
* 인터페이스의 한계 : 변경시 나머지 싹다 바뀌어야함.


* 유틸리티는 특정 연산 위한 거기 때문에. abstract 클래스로 하면 인지하기에도 좋은듯. 생성자 만들지 않아도 되고.
![[Pasted image 20240425232857.png]]