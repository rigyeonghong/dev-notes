# 배열의 특징1 - 배열과 인덱스

* 배열의 특징
	* 인덱스를 사용해 빠르게 자료 찾을 수 있음 : *백억건이든 십억건이든 한 번의 연산으로 위치 찾기* . O(1)

	![[Pasted image 20240610132234.png]]
	* 배열의 시작 참조 + (자료의 크기 * 인덱스 위치)
		ex. arr[1] : x100 + (4byte * 1) : x104

	* 그러나, 배열에 들어있는 데이터 찾는 검색은
		배열 내부 데이터 하나하나 비교해야하므로, 배열의 크기가 클 수록 오래 걸림. O(N)

# 빅오 표기법
* 알고리즘 성능 분석시 사용하는 수학적 표현 방식.
	알고리즘이 처리해야 할 데이터 양 증가시, 알고리즘이 얼마나 빠르게 실행되는지 나타냄.
	~~정확한 실행 시간이 아닌~~, 성능 변화 추세를 이해하는 것이므로 상수 제거.
	최적/최악 으로 구분해서 표현하기도 함. ex. 배열 검색
	
	![[Pasted image 20240610132920.png]]

	* O(1) : 배열 인덱스 사용
	* O(n) : 배열의 검색
	* O(n*2) : 2중 루프(재귀), 버블 정렬, 선택 정렬
	* O(log n) : 이진 탐색
	* O(n log n) : 병합 정렬, 힙 정렬

# 배열의 특징2 - 데이터 추가/삭제
* 데이터 중간에 추가시, 기존 데이터가 오른쪽으로 한 칸씩 이동해야함.

* 배열에 데이터 추가시 위치 변화 따른 성능 변화
	* 첫번째 위치 추가 
		* 찾기 : O(1) + 한칸씩 이동 : O(n) = O(n)
	* 중간 위치 추가
		* 찾기 : O(1) + 한칸씩 이동 : O(2/n) = O(n)
	* 마지막 위치 추가
		* 찾기 : O(1) = O(1)

* 데이터 삭제
	* 마지막 : O(1)
	* 앞, 중간 : O(n)

# 직접 구현하는 배열 리스트
* 배열 : 순서 존재, 중복 허용. *크기 정적 고정.*
* 리스트 : 순서 존재, 중복 허용. *크기 동적 변경.*

### 리스트 크기 동적 변경 위한 코드
```java
public void add(Object e) {
	if (size == elementData.length) {
		grow();
	}
	elementData[size] = e;
	size++;
}

public void grow() {
	int oldCapacity = elementData.length;
	int newCapacity = oldCapacity * 2; // 길이 2배로 증가

	Object[] newArr = Arrays.copyOf(elementData, newCapacity); 

	elementData = newArr; // 새 배열 참조하도록 변경
}
```

💡Object[] newArr = Arrays.copyOf(elementData, newCapacity); 
* 내부 호출 
	* System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); ➡️ 얕은 복사
		배열의 일부를 다른 배열로 빠르게 복사.
		original : 원본 배열
		copy : 복사된 데이터를 받을 대상 배열
		Math.min(original.length, newLength) : 복사할 요소의 수

💡 깊은 복사 vs 얕은 복사
* 깊은 복사
	객체의 실제 내용을 새 메모리에 복사. 서로 독립적.
* 얕은 복사
	원본 배열의 각 요소가 가리키는 참조만을 복사. 원본/복사된 배열에서 객체 내용 변경시, 두 배열 모두 영향.

![[Pasted image 20240610140830.png]]

### 타입 안정성 향상 위한 제네릭 사용
* `MyArrayListV4<E>` 로 제네릭 타입을 선언
* Object 로 입출력 받는 곳을 E로 변경

* `Object[] elementData` 을 그대로 사용하는 이유
	* 생성하려면 프로그램 실행돼서 돌아갈 때 타입을 알아야 하는데 `E[]`면 자바가 알 수 없음.







---

💡 study Q&A

Q. 객체 지향 프로그래밍(OOP) 장점?
	(모든 사물을 속성과 기능을 가진 객체로 생각하는 것) ➡️ 코드 읽기 쉽고, 변경 쉬움
	1. 모듈성 : 독립
	2. 재사용성
	3. 확장성 및 유지보수성 : 새기능 추가, 기존 코드 영향 주지 않고 업그레이드
	4. 캡슐화 : 내부 구현 숨기고, 외부 인터페이스만을 통해 상호작용 제공해 시스템 안정성 강화
	5. 상속 : 재사용성
	6. 다형성 : 코드양 줄이고 가독성 향상, 유연성 제공
	7. 테스트와 디버깅 용이성 : 코드를 더 작은 단위로 분할해 개별 테스트 디버깅에 쉬움

 
Q2.추상 클래스, 인터페이스에는 메서드의 바디가 작성되어 있지 않고 나중에 작성되는 경우 메서드 영역의 클래스 영역에서 어떻게 되는지.

추상 클래스나 인터페이스에서 메서드는 실제 구현이 없이 선언만 있습니다. 이러한 메서드들은 인스턴스화 될 때가 아니라, 서브 클래스에서 구현(오버라이드)될 때 메서드 영역의 클래스 영역에 구현 내용이 저장.

컴파일 시점에서 추상 메서드나 인터페이스의 메서드는 구현 내용 없이 메서드 시그니처만 메모리에 로드되고, 실행 시점에 구체 클래스에서 구현된 메서드가 메모리에 로드

```css
[메소드 영역] 
|--------------------------------------| 
| 클래스 정보: AbstractClass | 
| - 추상 메소드: methodA(), methodB() | 
|--------------------------------------| 
| 클래스 정보: Interface | 
| - 추상 메소드: methodC() | 
|--------------------------------------| 

[힙] 
|--------------------------------------| 
| 객체 인스턴스: ConcreteClass | 
| - 필드 데이터 | 
| - 구현된 메소드: methodA(), methodB()| 
|--------------------------------------| 

[스택] 
|--------------------------------------| 
| 메소드 스택 프레임: methodA() | 
| - 로컬 변수 | 
| - 파라미터 | 
|--------------------------------------|
```


Q3. static 메서드와 인스턴스 메서드의 저장 위치와 차이
* static 메서드와 인스턴스 메서드 모두 클래스 정보가 메서드 영역(Method Area)에 로드될 때 같이 저장
* 차이점은 호출 방법 : 메서드 호출 시 참조값(인스턴스)의 필요 유무.
	static 메서드는 클래스에 속해 있기에 클래스명만으로 직접 호출이 가능합니다. 반면, 인스턴스 메서드는 특정 객체가 생성되어야만 그 객체를 통해 호출



* ADT : 추상 자료형 : 자료들과 자료들에 대한 연산들의 집합.
	* ex. List : 구현 사항 없는 추상 자료형