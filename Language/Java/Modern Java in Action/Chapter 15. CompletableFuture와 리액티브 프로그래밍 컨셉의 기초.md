* Thread, Future, 자바가 동시성 API 제공하도록 강요하는 진화 힘
* 비동기 API
* 동시 컴퓨팅의 박스와 채널 뷰
* CompletableFuture 콤비네이터로 박스 동적 연결

#### 배경
* 멀티코어 프로세서 발전 -> 애플리케이션 속도는 멀티 코어 프로세서 얼마나 잘 활용하는 sw 개발하냐 
	* 지금껏, 한 개의 큰 task를 병렬로 실행할 수 있는 개별 하위 task로 분리 가능.
	* 자바 7부터, 포크/조인 프레임워크 사용 가능.
	* 자바 8부터, 병렬 스트림으로 스레드에 비해 단순 효과적 방법으로 병렬 실행 달성 가능.
* 인터넷 서비스 사용 애플리케이션 증가 현상. msa 증가 -> 하나의 거대 애플리케이션을 작은 서비스 나눠 nw 통신 증가.
	& 구글,페북, 트위터 공개 api로 다양한 소스 콘텐츠 가져와 매시업. -> 멀티태스킹 필요
	* 7장, 포크/조인 프레임워크와 병렬 스트림은 병렬성의 귀한 도구 -> 한 task를 여러 하위 task로 나눠 cpu 다른코어나 다른 머신에서 병렬 동작
* 동시성 필요하는 상황 (애플리케이션 생산성 극대화위해 코어 바쁘게) : 원격 서비스 / db 결과 기다리는 스레드 블록함으로 연산 자원 낭비 피하기

➡️ (자바 제공) 16,17장 Future 인터페이스, 자바8의 CompletableFuture, 자바9 플로API(17장)


# 15.1 동시성 구현하는 자바 지원의 진화

💡용어정리
* `Runnable` : `Runnable`을 구현하는 클래스의 인스턴스는 스레드가 실행할 작업을 정의
* `ExecutorService 인터페이스` : 스레드 풀을 사용하여 태스크(task)의 실행을 관리하는 인터페이스. 태스크 제출과 실행 분리(프로그래머가 작업 어떻게 실행할지 걱정 없이, 단지 실행하고자 하는 작업을 ExecutorService에 \출하면 됨).
* `Callable<T>` :  `Runnable`의 확장된 형태로, 작업이 완료된 후 결과를 반환할 수 있는 인터페이스.
* `Future<T>` : `Callable` 태스크의 결과를 나타내는 제네릭 인터페이스.

##  15.1.1 스레드와 높은 수준의 추상화
* 스트림 이용해 스레드 사용 패턴 추상화 가능.

💡용어정리
* 스트림(Stream) : Java 8에서 도입된 기능으로, 배열이나 컬렉션과 같은 데이터 소스를 함수형 스타일로 처리. 스트림 생성 후에는 다양한 중간 처리 연산(필터링, 매핑 등)과 최종 연산(카운트, 합계 등)을 수행. (원본 소스 -> 중간 연산 -> 최종 연산)
* parallel() : 트림을 병렬 스트림으로 변환 -> Fork/Join 프레임워크를 이용하여 스트림 연산을 여러 스레드에 분산시켜 처리

##  15.1.2 Executor와 스레드 풀
* 스레드 문제
	* 자바 스레드는 직접 os 스레드에 접근. os 스레드 생성/종료시 비싼 비용 & 수 제한.

* 스레드 풀 & 스레드 풀이 더 좋은 이유
	* 워커 스레드인 nThreads 포함하는 ExecutorService 생성 후 스레드 풀에 저장.
	* 사용하지 않은 스레드로 제출된 task 실행 후 풀로 반환
	* 장점
		* hw에 맞는 수의 task 유지 및 스레드 풀에 오버헤드 없이 수천개의 Task 제출 가능

* 스레드 풀 & 스레드 풀이 나쁜 이유 ➡️ 블록할 수 있는 테스크는 스레드 풀 제출하지 말아야함.
	*  잠을 자거나 I/O 기다림, nw 연결 기다리는 task 있다면 주의.
		I/O 기다리며 블록 상황에서 워커 스레드에 할당된 상태 유지하나 아무 작업 진행하지 않음.
	 * 데드락 가능성
	
##  15.1.3 스레드의 다른 추상화 : 중첩되지 않은 메서드 호출
![[IMG_727FB882B4F3-1.jpeg]]
* 비동기 메서드 사용시 위험성
	* 데이터 경쟁 문제 주의 : 메서드를 호출한 다음의 코드와 스레드 실행이 동시.
	* 실행 중이던 스레드 종료되지 않고, main() 메서드 반환시
		* 애플리케이션 크래시. 
		* 외부 데이터 일관성 파괴.
➡️ setDaemon() : 데몬 / 비대몬 구분.
	데몬 스레드 : 애플리케이션 종료시 강제 종료 : 데이터 일관성 파괴하지 않는 동작시
	main 메서드 : 비대몬 스레드가 종료될 때까지 기다림.

##  15.1.4 스레드에 무엇을 바라는가?
* 목표 : 모든 hw 스레드 활용 : 프로그램을 작은 task 단위로 구조화.

#  15.2 동기 API 와 비동기 API
* 자바8 스트림 : 명시적으로 병렬 hw 이용
	* 외부 반복(명시적 for 루프)을 내부 반복(스트림 메서드 사용)으로 변경
	* parallel() 이용 : 병렬로 처리

* 비동기 API
	* 


💡용어 정리
* 시그니처 : 특정 메서드를 고유하게 식별하는 데 사용되는 조합. 메서드의 이름과 함께 메서드의 매개변수 목록(타입 및 순서)으로 구성.






----
Q. 관심사분리와 정보은닉에 대해 설명해주세요 
	- 관심사분리 : 컴퓨터 프로그램을 고유 기능으로 나누는 동작을 권하는 원칙 -> 협업, 재사용, 유지보수
	- 정보은닉 : 세부 구현 숨기도록 장려하는 원칙. 
		- 요구사항 자주 바뀌어 세부구현 숨김으로 프로그램 어떤 부분 변경시, 다른 부분까지 영향 미칠 가능성 줄임
Q. 스레드 풀 사용의 장단점

Q. 발행-구독 관련..?



---
https://f-lab.kr/insight/understanding-reactive-programming

* 데이터 흐름과 전달에 중점을 둔 프로그래밍 패러다임
* 데이터나 이벤트가 발생할 때 이를 자동으로 감지하고 반응하여 처리하는 방식
	➡️ 비동기 데이터 흐름을 쉽게 관리하고, 복잡한 데이터 흐름을 효율적으로 처리
* ex. 사용자 인터페이스, 실시간 데이터 처리, 네트워크 요청 등 다양한 분야

* 핵심은 '옵저버 패턴'과 '반응형 시스템'
	* 옵저버 패턴 : 데이터 소스 관찰 -> 데이터 변화시 구독하는 컴포넌트에 자동 알림

* 장점
	* 데이터 흐름 명확 -> 코드 가독성, 유지보수성 향상
	* 비동기 처리와 에러 핸들링 용이 -> 에러 효과적 처리
	* 성능 향상, 생상선 향상, 어플 반응성 향상, 사용자 경험 향상
