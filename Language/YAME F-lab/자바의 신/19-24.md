* JDK : java Development Kit : 
* JRE : Java Runtime Environment : 실행만을 위한 환경 : 자바 실행할 수 있는 환경의 집합.

* JVM 덕에 어떤 플랫폼에도 동리한 결과. 호환성과 포터블한 환경 제공 가능.
* 높은 성능 : 실행환경에서 최대 성능 내도록 구현. 자동화된 GC


#### GC (가비지 컬렉터)
* 오라클 JDK 기준
	* 마이너 GC / 영 GC
		* young (eden(객체 생성하자마자 저장)/survivor(eden 꽉차면 복사되고 다시 eden 채움))/ old/ perm(클래스, 메소드 정보)
		* 오래 살아있으면 Old.
		* young GC가 더 작은 공간 할당이라 더 빠르게 참.
	* G1
	* Serial GC
	* Parallel Young GC
	* Parallel Old GC
	* Mark & Sweep
### set
* hashset : 순서 필요없는 해시테이블에 저장. set 중 좋은 성능
* treeset : 저장된 값에 따라 정렬되는 셋. red-black 트리 타입으로 hashset 보다 성능 약간 느림
* linkedhashset : 연결된 목록 타입으로 구현된 해시 테이블에 데이터 저장. 순서 따라 값 정렬. 성능 나쁨.



Q1. JIT 컴파일러에 관해 아는대로 설명
A1. Just In Time 동적 변환. 프로그램 실행 보다 빠르게 하기 위한 컴파일러지만, 실행시에 적용되는 기술. 정적 컴파일 방식과 인터프리터 방식을 혼합.
변환 작업은 인터프리터에 의해 지속적으로 수행되나, 필요한 코드의 정보는 캐시에 담아 재사용.
컴파일된 bytecode를 기계 코드로 변환하는 작업 수행.

Q2.Java에서 모든 클래스가 `java.lang.Object`를 상속받는 이유는 무엇인가요?
A2 `Object` 클래스는 Java의 모든 클래스의 최상위 클래스입니다. 이를 상속받음으로써 Java의 모든 객체는 `equals()`, `hashCode()`, `toString()` 등의 공통 메서드를 가질 수 있으며, 일관된 객체 관리 및 다형성을 구현할 수 있습니다. 즉, 모든 객체를 `Object` 타입으로 처리할 수 있어 유연한 코드를 작성할 수 있습니다.

Q3. 제네릭이란 무엇이며, Java에서 제네릭을 사용하는 이유는 무엇인가요?
A3. 제네릭(Generics)은 Java에서 **클래스, 인터페이스, 메서드**에 **타입 파라미터**를 사용하여 **타입 안정성**을 확보하고 **코드 재사용성**을 높이는 기능.
제네릭을 사용하면 컴파일 시에 타입을 체크할 수 있어 **타입 불일치 오류**를 방지할 수 있고, 여러 타입에 대해 동일한 코드를 작성할 수 있습니다. 

Q4. 제네릭  선언시 와일드카드 선언시, 어떤 제약 사항이 있나요?
A4. 와일드 카드는 메소드의 매개변수로만 사용하는 것이 좋다.


Q5. equals()와 hashcode()에 대해 설명해 주세요.
A5. `equals()`와 `hashCode()` 메서드는 객체 비교에 중요한 역할을 합니다. 
두 객체가 `equals()`에 의해 동일하다고 판단되면, 그들의 `hashCode()` 값도 동일해야 합니다. 이 규칙을 지키지 않으면, `HashMap`이나 `HashSet` 같은 해시 기반 컬렉션에서 문제가 발생할 수 있습니다. 

* 이 메서드를 적절히 구현하는 방법을 말해보세요.
	* 적절하게 구현하려면 `equals()`에서 객체의 중요한 필드들을 비교하고, `hashCode()`는 동일한 필드로 해시값을 생성해야 합니다.


Q6. `ArrayList`와 `LinkedList`의 차이점은 무엇인가요?
A6 `ArrayList`와 `LinkedList`는 `List` 인터페이스를 구현하지만, 내부 구현과 성능 특성에서 차이가 있습니다.
    - **`ArrayList`**: 내부적으로 **배열**을 사용하여 요소를 저장합니다. **인덱스를 통한 요소 접근**은 빠르지만, **삽입/삭제**가 배열의 크기를 조정해야 할 때 느려질 수 있습니다.
    - **`LinkedList`**: 내부적으로 **이중 연결 리스트**로 구현되어 있어, **삽입/삭제**가 빠릅니다. 하지만 인덱스를 통한 접근은 리스트를 순차적으로 탐색해야 하기 때문에 **느립니다**.
    - **주요 차이점 요약**:
        - `ArrayList`: **랜덤 접근이 빠름** (O(1)), 삽입/삭제가 느림 (O(n))
        - `LinkedList`: **삽입/삭제가 빠름** (O(1), 리스트 앞뒤에서), 랜덤 접근이 느림 (O(n))

Q7.`HashSet`과 `TreeSet`의 차이점은 무엇인가요?
A7. `HashSet`과 `TreeSet`은 모두 `Set` 인터페이스의 구현체지만, 내부 동작 방식과 성능에서 차이가 있습니다.
    - **`HashSet`**:
        - **내부적으로 해시맵(HashMap)**을 사용해 요소를 저장합니다.
        - **순서를 보장하지 않으며**, 요소의 추가, 삭제, 조회가 **O(1)**의 시간 복잡도를 가집니다.
        - **null** 요소를 허용합니다.
    - **`TreeSet`**:
        - **이진 검색 트리(레드-블랙 트리)**를 기반으로 요소를 저장하므로 **정렬된 순서**를 유지합니다.
        - 요소의 추가, 삭제, 조회가 **O(log n)**의 시간 복잡도를 가집니다.
        - **정렬된 순서**를 유지하기 때문에, 기본적으로 **Comparator**나 **Comparable**을 통해 요소를 비교합니다.
        - **null** 요소를 허용하지 않습니다.

**결론**: 빠른 조회 성능이 필요하고 순서가 중요하지 않다면 `HashSet`을, 순서가 중요한 경우나 정렬된 컬렉션이 필요하다면 `TreeSet`을 사용합니다.
