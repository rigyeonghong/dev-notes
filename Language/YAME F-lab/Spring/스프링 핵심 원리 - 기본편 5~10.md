# 웹 애플리케이션과 싱글톤

* 웹 애플리케이션은 고객이 계속 요청해야하는데 new Client() 한다고 계속 만들어도 되는가?
	* 고객 트래픽이 초당 100이 나오면 초당 100개 객체가 생성되고 소멸! = 메모리 낭비
	* 객체 1개 생성 후 공유하도록 설계 하면 됨 = 싱글톤 패턴
	* -> 사실 gc 가 빨라서 요즘은 상관X

* 싱글톤 패턴
	* 클래스 인스턴스 1개
	```JAVA
	public class Service {
		// 클래스 레벨에 올라가서 하나만 존재. = static
		private static final SingletonService instance = new SingletonService();
		// `final`이 변수에 사용되면, 해당 변수는 초기화된 후 다시 값을 변경할 수 없음 != 불변
		// - 기본 데이터 타입의 경우, 값이 변경될 수 없음 의미.
		// - 참조 타입(객체)의 경우, 해당 변수에 다른 객체를 할당할 수 없음을 의미하지만, 그 객체의 상태는 변경될 수 있음


		// 항상 같은 인스턴스 반환
		public static SingletonService agetInstance(){
			return instance;
		}

		// 이렇게 만들면 외부에서 Service sv1 = new Service(); new 키워드로 못만들게 강제!!
		// 만들려 하려면 컴파일 오류 나니까!! 잘 설계한 객체임 >< 
		private SingletonService() {
		}

		public void logic(){
			soutv("싱글톤 객체 로직 호출");
		}
	}```

```java
psvm(String[] args){
	// 싱글톤을 내부에 감추려 해도 해당 클래스 new 하는 순간 싱글톤 인스턴스도 생김 
	// private SingletonService() 추가 후 아래처럼 new 불가
	/* Service sv1 = new Service();
	Service sv2 = new Service(); */
	// 클래스 로딩 시 미리 생성된 인스턴스를 사용하기 때문에 따로 `new`를 호출하지 않아도 됨
	SingletonService ss1 = SingletonService.getInstance();
}
```


* 싱글톤 패턴 문제
	* 테스트 어려움 : 지정해서 가져오고 설정 끝나서 : 유연 테스트 어려움
	* 의존관계상 클라이언트가 구체 클래스에 의존. 구체클래스.instance() 로 꺼내야함 : DIP 위반
	* private 생성자로 자식 클래스 만들기 어려움
	* 유연성 떨어짐 : DI 못해서 안티패턴으로 불리기도.

-> 싱글톤 패턴 문제 제거하고 객체 싱글톤으로 관리해줘.
# 싱글톤 컨테이너
* 스프링 컨테이너가 객체 인스턴스 1개만 관리. = 스프링 빈(싱글톤=1개로 관리되는 빈)
* DIP,OCP,테스트, private 생성자로부터 자유.

```java
ApplicationContext ac = AnnotationConfigApplicationContext(AppConfig.class);
Service ss1 = ac.getBean("ss", Service.class);
Service ss2 = ac.getBean("ss", Service.class);
```


* 싱글톤 외
	* http 리퀘스트 사이클 : 고객 들어올 때 만들고 나갈 때 죽이거나
	* http session 스코프 맞춰.

### 싱글톤 방식 주의점
* 무상태로 설계!!
	* 특정 클라이언트 의존 X
	* 값 변경 X
	* 가급적 읽기만
	* 필드 대신 공유되지 않는, 지역변수, 파라미터, ThreadLocal 사용

# @Configuration과 싱글톤
* `new MemberRepository()` 여기저기서 호출하면 싱글톤 깨지지 않나? 
	* 여기저기서 `new MemberRepository()` 불러도 한 번 불렀으면, 다시 호출하지 않는듯.
* @Configuration
	* getClass()시 xxCGLIB 붙으면 -> CGLIB(바이트코드 조작 라이브러리)로 상속받는 임의 다른 클래스 생성 => 이걸로 싱글톤 되도록 보장.
	* ex. 있으면 찾아서 반환해, 없으면 생성해 로직이 안에 숨어있을듯.

* @Bean 스프링 빈 등록이나, 싱글톤 보장X

# @ComponentScan
* @ComponentScan 붙은 class 다 스프링 빈으로 등록


# 의존관계 자동 주입
* 스프링 컨테이너가 관리하는 스프링 빈이어야 동작.
* 생성자 주입
	* 생성자 호출시점 딱 1번 호출이 보장.
	* 불변!!
	* @Autowired
	* 사실 빈 등록하려면, new 호출해야해 -> 스프링 컨테이너에서 찾아와서 자동 주입해. 1번째 단계
* 수정자 주입(setter 주입)
	* 2번째 단계.
	* 선택적이거나 변경 가능할 때 사용
* 필드 주입
	```java
	@Autowired private Policy policy();	
```
	* 외부 변경이 어려워 테스트의 어려움.. 테스트 하려면 setter 주입을 만들어야해서.
	* 쓰지마라!
* 일반 메서드 주입
	* 한 번에 여러 필드 주입
	* 잘 사용x


### 롬복과 최신 트랜드
* 막상 개발하면 대부분 불변 -> 생성자에 final 키워드 사용
* 


# 빈 생명주기 콜백



# 빈 스코프



---
* ~~1. 싱글톤 패턴에 대해 설명해주세요
	*  단 하나의 인스턴스를 생성해 사용하는 디자인 패턴.
	* 인스턴스가 1개만 존재해야 한다는 것을 보장하고 싶은 경우와 동일한 인스턴스를 자주 생성해야 하는 경우에 주로 사용합니다. (메모리 낭비 방지)
	* 대표 예시, Spring Bean. 스프링의 빈 등록 방식은 기본적으로 싱글톤 스코프이고, 스프링 컨테이너는 모든 빈들을 싱글톤으로 관리

	* 1-1.문제점

* 2. 클래스 로딩에 대해 설명 (https://velog.io/@skyepodium/%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EC%96%B8%EC%A0%9C-%EB%A1%9C%EB%94%A9%EB%90%98%EA%B3%A0-%EC%B4%88%EA%B8%B0%ED%99%94%EB%90%98%EB%8A%94%EA%B0%80)
	* 언제 되는지
	* 초기화 진행 순서
		* static 변수 선언부 : 클래스가 로드 될 때 변수가 제일 먼저 초기화 된다.
		- 필드 변수 선언부 : 객체가 생성될 때 생성자 block 보다 앞서 초기화 된다.
		- 생성자 block : 객체가 생성될 때 JVM이 내부적으로 locking( thread-safe 영역 )
	* 정적 변수 호출, final (o,x)
	* 정적 내부 클래스는

* 3. 각기 다른 스레드나 메서드 호출 간에 공유되지 않는 변수들은 어떤 것이 있는지 설명해주세요
	* 지역 변수 : 메서드, 생성자 또는 블록 내 선언된 변수.
		* 메서드나 블록 실행시에만 존재, 종료되면 메모리에서 사라짐
	* 메서드 파라미터 : 메서드 호출시 전달된 값 받기 위해 메서드 선언부에 정의된 변수
		* 해당 메서드 내에서만 유효.
	* threadLocal : 스레드에서 독립적으로 변수 가질 수 있도록 해주는 클래스
		* 같은 threadLocal 인스턴스 사용하는 모든 스레드가 각기 다른 값 가짐. 

* 4. 지역 변수와 인스턴스 변수의 차이?
	* 지역 변수 : 메서드, 생성자, 블록 내부 선언. 선언된 블록내에서만 유효.
	* 인스턴스 변수 : 클래스 수준에서 메서드나 생성자 외부에 선언. 인스턴스 존재하는동안 유효.
		* 객체가 생성될 때 함께 생성되며, gc에 의해 소멸될 때 함께 사라짐
	* 둘다 Heap 영역에 로드

* 5. Java의 GC에 대해 설명해 주세요.
	* A. JVM의 메모리 관리 기법 중 하나로 시스템에서 동적으로 할당됐던 메모리 영역 중에서 필요없어진 메모리 영역을 회수하여 메모리를 관리해주는 기법
	* 5-1. 가비지 컬렉션 과정
		GC의 작업을 수행하기 위해 JVM이 어플리케이션의 실행을 잠시 멈추고, GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업을 중단 후 (Stop The World 과정) 사용하지 않는 메모리를 제거(Mark and Sweep 과정)하고 작업이 재개
		
	*  finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?
	- 5-2. 어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?
		- 객체에 대한 참조가 더 이상 없을 때
		- **다른 참조가 존재할 때**: 객체가 여전히 다른 변수, 객체, 또는 스레드에 의해 참조되고 있다면, 그 객체는 여전히 유효하며 가비지 컬렉션의 대상이 되지 않
			- **GC 타이밍**: `null`로 설정된 객체가 GC의 대상이 되더라도, 실제로 가비지 컬렉션이 언제 실행될지는 JVM의 GC 알고리즘과 메모리 상황에 따라 다름


* 6. **Java에서 제공하는 원시 타입들에 무엇이 있고, 각각 몇 바이트를 차지하나요?**
	* - 정수형 byte, short, int, long 실수형 float, double 문자형 char 논리형 boolean이 있고,
- 정수형 1, 2, 4, 8, 실수형 4, 8, 문자형 2, 논리형 1 바이트를 차지.


* pass by value, pass by reference 의 차이에 대해 설명.
	* pass by value : 값을 전달 => 모든 기본 자료형
	* pass by reference  : 참조를 전달 => 참조 자료형
* #### Call by reference란 무엇이고 보통 어떻게 쓰이나요?
	* Call by value (값에 의한 호출)는 메소드에 변수를 전달할 때, 해당 변수의 값이 복사되어 메소드 내에서 사용
	* 메소드 내에서 변수의 값을 변경하더라도 호출자의 변수는 변경되지 않습니다
	* 스프링에서는 메소드 호출 시 일반적으로 Call by value 방식

	* Call by reference (참조에 의한 호출)은 메소드에 변수를 전달할 때 변수의 참조(메모리 주소)가 전달되며, 메소드 내에서 변수를 수정하면 호출자의 변수도 변경
	* 자바에서 직접 지원하지 않습니다. 대신 객체를 전달하여 객체 내부의 상태를 변경

* ~~7.  java의 기본 타입은 call by value고 참조타입은 call by reference다?
	* java는 call by value로 작동
	* java의 참조변수에는 원본 객체에 대한 참조를 값으로 복사하여 가지고 있습니다. 즉 변수가 가지는 값이 레퍼런스이므로 인자로 넘길 때 call by value에 의해 변수가 가지고 있는 레퍼런스가 복사되어 전달되는것

* 7-1. 참조 변수란
	* Java에서 객체를 가리키는 변수입니다. 참조 변수는 실제로 객체 자체를 저장하는 것이 아니라, 객체가 메모리의 어느 위치에 존재하는지를 가리키는 **참조(Reference)**를 저장

* ~~8. new String()과 리터럴("")의 차이에 대해 설명해주세요.
	* - new String()은 new 키워드로 새로운 객체를 생성하기 때문에 Heap 메모리 영역에 저장되고,
	- ""는 Heap 안에 있는 String Constant Pool 영역에 저장

* ~~9. 접근 제한자(Access Modifier)에 대해 설명해주세요.
	* ~~변수 또는 메소드의 접근 범위를 설정해주기 위해서 사용하는 Java의 예약어를 의미하며, 총 4 가지 종류
		* public - 접근 제한 x
		* protected - 해당 패키지 내, 상속받은 경우 접근 가능
		* default - 해당 패키지 내에서만 접근
		* private - 해당 클래스에서만 접근

10. 오버로딩과 오버라이딩의 차이
	* 오버라이딩이란 상위 클래스의 메서드를 재정의
	* 오버로딩이란 메서드의 이름은 같고 파라메터의 갯수나 타입이 다른 함수를 정의. 리턴값만을 다르게 갖는 오버로드는 작성 할 수 없습니다.

~~11. 롬복(Lombok)이란
	1. Java 애플리케이션 개발에서 반복적으로 작성해야 하는 보일러플레이트 코드(예: getter, setter, equals, hashCode, toString 메서드, 생성자 등)를 자동으로 생성해주는 라이브러리

12. final 키워드를 사용하면, 어떤 이점이 있나요?
	* 해당 변수가 초기화된 이후에는 값을 변경할 수 없습니다. 이로인해 코드의 의도를 명확히 할 수 있으며, 특정 값이 변경되지 않도록 보장
	* 12-1. 그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?
		* 변수 : 상수로 취급. 한 번 초기화 후 값 변경 불가
		* 메서드 : 하위클래스에서 오버라이드 불가. `final` 메서드를 호출하는 코드를 최적화 가능.
		* 클래스 : 상속 불가. 가상 메서드 테이블(Virtual Method Table)을 통해 동적으로 호출할 필요가 없으며 동적 호출 필요 없어 성능 향상
		* 컴파일 타임 검사 : 한번만 초기화 될 수 있음. 여러 번 초기화되거나, 초기화되지 않은 상태에서 사용되는지 여부를 철저히 검사합니다. 이를 통해 코드의 신뢰성과 안전성을 높일 수 있음.
		* -> 컴파일러 최적화(상수 인라인이나 메서드 호출 최적화), 오류 예방(컴파일러가 초기화 상태 검사), 성능 향상(상속 오버라이딩 불가로 메서드 호출 더 최적화)

13. ~~Spring Bean Life Cycle에 대한 설명
	* bean의 생성부터 소멸까지의 과정을 뜻
	* 스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸 전 콜백 -> 스프링 종료.
	* 객체 생성후 의존관계 주입이 끝난 뒤 초기화 콜백을 받은 후 초기화를 한 후 소멸전 콜백을 받아 소멸이 된다.

* Bean이란
	* spring IoC 컨테이너가 관리하는 자바 객체를 빈(Bean)이라는 용어
	* 우리가 new 연산자로 어떤 객체를 생성했을 때 그 객체는 빈이 아니다.

~~14.  IoC 컨테이너의 역할
	* 객체를 생성하고 관리하고 의존성을 관리해주는 컨테이너다. 이 때 컨테이너가 설정정보를 바탕으로 자동으로 DI를 해줌.

~~15. 배열과 링크드 리스트의 차이
	* 배열 : 정적인 구조다. 미리 크기를 정해놓아야 하고, 수정이 불가능.
		* 연속된 메모리 주소를 할당받기 때문에 인덱스를 가지게 되서 검색 속도가 O(1)의 시간복잡도.
		* 탐색이 중요하면 배열을 쓰는것이 좋다
	* 연결 리스트 : 동적인 구조다. 크기를 미리 저장할 필요가 없고, 데이터가 추가됨에 따라 크기가 늘어나고 이 데이터들은 노드(값 + 다음 데이터 메모리 주소)를 통해 연결되고 추가 삭제가 용이
		* 검색 속도는 O(n)의 시간복잡도를 가져 배열보다 느리기 때문에 추가, 삭제가 용이하다면 연결리스트가 좋다

16. ~~Setter를 무분별하게 사용하면 안되는 이유
    - ~~엔티티를 작성할 때 Setter를 무분별하게 사용하면 객체(Entity)의 값을 변경할 수 있으므로 객체의 일관성을 보장할 수 없다.


