## 4.1 MySQL 엔진 아키텍처

![](https://github.com/rigyeonghong/dev-notes/blob/main/Real-MySQL/RealMySQL1%202.jpeg)

* MySQL 서버 : MySQL 엔진(머리) + 스토리지 엔진(손발)
	* 스토리지 엔진 : 핸들러 API 만족시 구현해서 추가 가능.

* MySQL 엔진(머리) 
	* 커넥션 핸들러 : 클라이언트로부터의 접속, 쿼리 요청 처리
	* SQL 파서
	* 전처리기
	* 옵티마이저 : 쿼리 최적화 실행 위함.

* 스토리지 엔진(손발)
	: 실제 데이터를 디스크 스토리지에 저장, 디스크 스토리지로부터 데이터 읽어옴.
	* 여러 개 동시 사용 가능.
	* 각각 성능 향상 위해 키 캐시(MyISAM 스토리지 엔진), 버퍼 풀(InnoDB 스토리지 엔진) 기능 내장

* 핸들러 API
	* MySQL 엔진의 쿼리 실행기에서 데이터 읽고 쓸 때, 각 스토리지엔진에 요청시 사용되는 API


#### 4.1.2 MySQL 스레딩 구조
* 스레드 기반 작동.
	* 포그라운드 스레드 : 커넥션 연결, 스레드 캐시.
		* 최소 MySQL 서버에 접속한 클라이언트 수만큼 존재. 클라이언트 요청 쿼리 문장 처리.
		* 클라이언트 작업 마치고 커넥션 종료시, 스레드 캐시로 돌아감.
		* 일정 개수 이상 대기 중인 스레드 존재시, 스레드 캐시 넣지 않고 종료시킴. 
		* 데이터를 MySQL의 데이터 버퍼, 캐시, 디스크의 데이터, 인덱스 파일로 부터 읽어옴.
			* MyISAM 테이블은 디스크 쓰기까지 포그라운드 스레드가 처리.
			* InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드, 나머지는 백그라운드 스레드.
	* 백그라운드 스레드 (InnoDB 해당)
		* 인서트 버퍼를 병합하는 스레드
		* **로그를 디스크로 기록하는 로그 스레드**
		* InnoDB **버퍼 풀의 데이터를 디스크에 기록하는 쓰기 스레드**
		* 데이터를 버퍼로 읽어 오는
		* 잠금이나 데드락을 모니터링 하는

		* 데이터 쓰기는 지연되어 처리가능. 데이터 읽기 작업은 절대 지연될 수 없으므로 쓰기 작업 버퍼링해서 일괄 처리 기능 탑재한 InnoDB ↔️ MyISAM 사용자 스레드가 쓰기 작업까지 함께 처리.

* 스레드 풀 모델 
	* MySQL 엔터프라이즈 에디션에서 사용 가능.
	* 하나의 스레드가 여러개의 커넥션 요청 전담.

#### 4.1.3 메모리 할당 및 사용 구조
![[RealMySQL1 3.jpeg]]

* 글로벌 메모리 영역
	* MySQL 서버 시작하며 os로부터 할당.
	* 모든 스레드에 의해 공유
* 로컬(세션) 메모리 영역
	* 클라이언트 스레드가 쿼리를 처리하는데 사용하는 영역
	* 클라이언트 커넥션으로부터 요청 처리 위해 스레드 하나씩 할당. 절대 공유 x

#### 4.1.4 플러그인 스토리지 엔진 모델
* 플러그인 모델
	* 스토리지 엔진 / 검색어 파서 / 인증
* 스토리지 엔진 : 읽기/쓰기 영역.
* 핸들러 : MySQL 엔진이 각 스토리지 엔진에게 데이터 읽어오거나 저장하도록 명령하려면 핸들러 통해야함.
* GROUP BY, ORDER BY 등 복잡한 처리는 MySQL 엔진의 쿼리 실행기에서 처리.

* 여러 하위 작업으로 이뤄진 하나의 쿼리 작업. **각 하위 작업이'MySQL 엔진 영역'과 '스토리지 엔진 영역' 중 어디서 처리되는지 구분할 줄 알아야함.‼️**

* MySQL 서버(mysqld)

#### 4.1.5 컴포넌트
* MySQL 8.0 부터 플러그인 아키텍처 대체한 컴포넌트 아키텍처 지원.
	* 플러그인 단점 
		* 플러그인끼리 통신 불가.
		* MySQL 서버의 변수, 함수 직접 호출하기 때문에 안전하지 않음(캡슐화 안됨)
		* 상호 의존 관계 설정할 수 없어 초기화 어려움

#### 4.1.6 쿼리 실행 구조
* 쿼리 파서 : 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만드는 작업. 기본 문법 오류 발견.
* 전처리기 : 파서에서 만든 트리 기반 쿼리 문장의 구조적 문제 확인. 각 토큰을 테이블 이름/칼럼 이름 개체 매핑해 해당 객체 존재 여부, 접근 권한 확인
* 옵티마이저 : 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정.
* 실행 엔진 : 만들어진 계획대로 각 핸들러에 요청해 받은 결과를 또 다른 핸들러 요청의 입력으로 연결.
	* ex. 핸들러에 임시 테이블 만들라고 요청, where절에 일치하는 레코드 읽어오라 핸들러에 요청
* 핸들러 : 스토리지엔진. MySQL 실행 엔진 요청 따라 데이터를 디스크에 저장, 읽어옴.

#### 4.1.7 복제
중요함. 16장 '복제' ㄱㄱ

#### 4.1.8 쿼리 캐시
* 빠른 응답 필요로 하는 웹기반 응용 프로그램에서 중요한 역할.
* SQL 실행 결과를 메모리에 캐시, 동일 SQL 쿼리 실행시 즉시 결과 반환 ➡️ 빠른 성능
	* but 테이블 변경시 캐시 중 관련 테이블 삭제 ➡️ 동시 처리 성능 저하 유발 ➡️  MySQL 8.0 제거

#### 4.1.9 스레드 풀
* 목적 : 내부적으로 사용자의 요청 처리 스레드 개수를 줄여 동시 처리 요청 많아도, MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중하도록. ➡️ 서버의 자원 소모 절감
* Percona Server 의 스레드 풀 플러그인
	* 선순위 큐와 후순위 큐 : 특정 트랜잭션, 쿼리 우선 처리 가능. 먼저 시작된 트랜잭션 내 속한 SQL 빨리 처리. ➡️  해당 트랜잭션 갖고 있는 잠금 빨리 해제 & 잠금 경합 낮춰 처리 성능 향상.

#### 4.1.10 트랜잭션 지원 메타데이터
* 메타데이터 : db 서버에서 테이블 구조 정보, 스토어드 프로그램(SQL 명령문 모아둔 곳) 등 정보
* MySQL8.0부터 InnoDB 테이블에 저장. mysql.ibd  ➡️ 트랜잭션 지원
* InnoDB 외 스토리지 엔지 사용시 SDI 파일 사용.


## 4.2 InnoDB 스토리지 엔진 아키텍처
* 레코드 기반 잠금 제공 : 스토리지 엔진 중 거의 유일. ➡️ 높은 동시성 처리 가능, 안정, 성능 향상.
![[RealMySQL1 5.jpeg]]

#### 4.2.1 프라이머리 키에 의한 클러스터링
* 모든 테이블 프리이머리 키 기준으로 클러스터링 되어 저장. = 프라이머리 키 값 순서대로 디스크 저장. ➡️ 프라이머리 키 이용한 레인지 스캔 빠름.
	* 세컨더리 인덱스는 레코드 주소 대신 프라이머리 키의 값을 논리적 주소로 사용.
* ↔️ MyISAM 스토리지 엔진 : 클러스터링 키 지원 x
	* 프라이머리 키 포함 모든 인덱스는 물리적 레코드의 주소 값 가짐.

#### 4.2.2 외래 키 지원
* 부모, 자식 테이블 모두 해당 칼럼 인덱스 생성 필요 & 변경시 부모, 자식 테이블 데이터 있는지 체크 작업 필요하므로 잠금이 려러 테이블로 전파, 그로 인해 데드락 발생할 때 많으므로 개발시 주의!
* 수동 데이터 적재, 스키마 변경 등 관리 작업 실패 가능. 외래키가 복잡하게 얽힌 경우.
	* foreign_key_checks 시스템 변수 OFF 설정시, 외래 키 관계 체크 작업 일시 멈춤.
	* 속도 빨라지나, 부모 삭제시 자식도 삭제해서 일관성 유지 필요.

#### 4.2.3 MVCC(Multi Version Concurrency Control)
* 목적 : 잠금 사용 않는 일관된 읽기 제공.
* 방법 : **언두 로그** 이용해 기능 구현. (하나의 레코드에 대해 여러 버전 동시 관리 & 필요에 따라 보여지는 데이터 달리함.)
	* 언두 로그 : InnoDB 버퍼 풀이나 데이터 파일 있는 내용 대신 변경 이전 내용.
* commit : 현 상태를 영구 데이터화.
* rollback : 언두 영역의 백업 데이터를 InnoDB 버퍼 풀로 복구, 언두 영역 내용 삭제.

#### 4.2.4 잠금 없는 일관된 읽기
* MVCC 기술 이용해 잠금 걸지 않고 읽기 수행.
	* ex. a 사용자가 레코드 변경 후 커밋 전. b 사용자 읽기 작업시 언두 로그 사용.

#### 4.2.5 자동 데드락 감지
* 


## 4.3 MyISAM 스토리지 엔진 아키텍처



## 4.4 MySQL 로그 파일

