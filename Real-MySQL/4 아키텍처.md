## 4.1 MySQL 엔진 아키텍처

![](https://github.com/rigyeonghong/dev-notes/blob/main/Real-MySQL/RealMySQL1%202.jpeg)

* MySQL 서버 : MySQL 엔진(머리) + 스토리지 엔진(손발)
	* 스토리지 엔진 : 핸들러 API 만족시 구현해서 추가 가능.

* MySQL 엔진(머리) 
	* 커넥션 핸들러 : 클라이언트로부터의 접속, 쿼리 요청 처리
	* SQL 파서
	* 전처리기
	* 옵티마이저 : 쿼리 최적화 실행 위함.

* 스토리지 엔진(손발)
	: 실제 데이터를 디스크 스토리지에 저장, 디스크 스토리지로부터 데이터 읽어옴.
	* 여러 개 동시 사용 가능.
	* 각각 성능 향상 위해 키 캐시(MyISAM 스토리지 엔진), 버퍼 풀(InnoDB 스토리지 엔진) 기능 내장

* 핸들러 API
	* MySQL 엔진의 쿼리 실행기에서 데이터 읽고 쓸 때, 각 스토리지엔진에 요청시 사용되는 API


#### 4.1.2 MySQL 스레딩 구조
* 스레드 기반 작동.
	* 포그라운드 스레드 : 커넥션 연결, 스레드 캐시.
		* 최소 MySQL 서버에 접속한 클라이언트 수만큼 존재. 클라이언트 요청 쿼리 문장 처리.
		* 클라이언트 작업 마치고 커넥션 종료시, 스레드 캐시로 돌아감.
		* 일정 개수 이상 대기 중인 스레드 존재시, 스레드 캐시 넣지 않고 종료시킴. 
		* 데이터를 MySQL의 데이터 버퍼, 캐시, 디스크의 데이터, 인덱스 파일로 부터 읽어옴.
			* MyISAM 테이블은 디스크 쓰기까지 포그라운드 스레드가 처리.
			* InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드, 나머지는 백그라운드 스레드.
	* 백그라운드 스레드 (InnoDB 해당)
		* 인서트 버퍼를 병합하는 스레드
		* **로그를 디스크로 기록하는 로그 스레드**
		* InnoDB **버퍼 풀의 데이터를 디스크에 기록하는 쓰기 스레드**
		* 데이터를 버퍼로 읽어 오는
		* 잠금이나 데드락을 모니터링 하는

		* 데이터 쓰기는 지연되어 처리가능. 데이터 읽기 작업은 절대 지연될 수 없으므로 쓰기 작업 버퍼링해서 일괄 처리 기능 탑재한 InnoDB ↔️ MyISAM 사용자 스레드가 쓰기 작업까지 함께 처리.

* 스레드 풀 모델 
	* MySQL 엔터프라이즈 에디션에서 사용 가능.
	* 하나의 스레드가 여러개의 커넥션 요청 전담.

#### 4.1.3 메모리 할당 및 사용 구조
![[RealMySQL1 3.jpeg]]

* 글로벌 메모리 영역
	* MySQL 서버 시작하며 os로부터 할당.
	* 모든 스레드에 의해 공유
* 로컬(세션) 메모리 영역
	* 클라이언트 스레드가 쿼리를 처리하는데 사용하는 영역
	* 클라이언트 커넥션으로부터 요청 처리 위해 스레드 하나씩 할당. 절대 공유 x

#### 4.1.4 플러그인 스토리지 엔진 모델
* 플러그인 모델
	* 스토리지 엔진 / 검색어 파서 / 인증
* 스토리지 엔진 : 읽기/쓰기 영역.
* 핸들러 : MySQL 엔진이 각 스토리지 엔진에게 데이터 읽어오거나 저장하도록 명령하려면 핸들러 통해야함.
* GROUP BY, ORDER BY 등 복잡한 처리는 MySQL 엔진의 쿼리 실행기에서 처리.

* 여러 하위 작업으로 이뤄진 하나의 쿼리 작업. **각 하위 작업이'MySQL 엔진 영역'과 '스토리지 엔진 영역' 중 어디서 처리되는지 구분할 줄 알아야함.‼️**

* MySQL 서버(mysqld)

#### 4.1.5 컴포넌트
* MySQL 8.0 부터 플러그인 아키텍처 대체한 컴포넌트 아키텍처 지원.
	* 플러그인 단점 
		* 플러그인끼리 통신 불가.
		* MySQL 서버의 변수, 함수 직접 호출하기 때문에 안전하지 않음(캡슐화 안됨)
		* 상호 의존 관계 설정할 수 없어 초기화 어려움

#### 4.1.6 쿼리 실행 구조
* 쿼리 파서 : 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만드는 작업. 기본 문법 오류 발견.
* 전처리기 : 파서에서 만든 트리 기반 쿼리 문장의 구조적 문제 확인. 각 토큰을 테이블 이름/칼럼 이름 개체 매핑해 해당 객체 존재 여부, 접근 권한 확인
* 옵티마이저 : 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정.
* 실행 엔진 : 만들어진 계획대로 각 핸들러에 요청해 받은 결과를 또 다른 핸들러 요청의 입력으로 연결.
	* ex. 핸들러에 임시 테이블 만들라고 요청, where절에 일치하는 레코드 읽어오라 핸들러에 요청
* 핸들러 : 스토리지엔진. MySQL 실행 엔진 요청 따라 데이터를 디스크에 저장, 읽어옴.

#### 4.1.7 복제
중요함. 16장 '복제' ㄱㄱ

#### 4.1.8 쿼리 캐시
* 빠른 응답 필요로 하는 웹기반 응용 프로그램에서 중요한 역할.
* SQL 실행 결과를 메모리에 캐시, 동일 SQL 쿼리 실행시 즉시 결과 반환 ➡️ 빠른 성능
	* but 테이블 변경시 캐시 중 관련 테이블 삭제 ➡️ 동시 처리 성능 저하 유발 ➡️  MySQL 8.0 제거

#### 4.1.9 스레드 풀
* 목적 : 내부적으로 사용자의 요청 처리 스레드 개수를 줄여 동시 처리 요청 많아도, MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중하도록. ➡️ 서버의 자원 소모 절감
* Percona Server 의 스레드 풀 플러그인
	* 선순위 큐와 후순위 큐 : 특정 트랜잭션, 쿼리 우선 처리 가능. 먼저 시작된 트랜잭션 내 속한 SQL 빨리 처리. ➡️  해당 트랜잭션 갖고 있는 잠금 빨리 해제 & 잠금 경합 낮춰 처리 성능 향상.

#### 4.1.10 트랜잭션 지원 메타데이터
* 메타데이터 : db 서버에서 테이블 구조 정보, 스토어드 프로그램(SQL 명령문 모아둔 곳) 등 정보
* MySQL8.0부터 InnoDB 테이블에 저장. mysql.ibd  ➡️ 트랜잭션 지원
* InnoDB 외 스토리지 엔지 사용시 SDI 파일 사용.


## 4.2 InnoDB 스토리지 엔진 아키텍처
* 레코드 기반 잠금 제공 : 스토리지 엔진 중 거의 유일. ➡️ 높은 동시성 처리 가능, 안정, 성능 향상.
![[RealMySQL1 5.jpeg]]

#### 4.2.1 프라이머리 키에 의한 클러스터링
* 모든 테이블 프리이머리 키 기준으로 클러스터링 되어 저장. = 프라이머리 키 값 순서대로 디스크 저장. ➡️ 프라이머리 키 이용한 레인지 스캔 빠름.
	* 세컨더리 인덱스는 레코드 주소 대신 프라이머리 키의 값을 논리적 주소로 사용.
* ↔️ MyISAM 스토리지 엔진 : 클러스터링 키 지원 x
	* 프라이머리 키 포함 모든 인덱스는 물리적 레코드의 주소 값 가짐.

#### 4.2.2 외래 키 지원
* 부모, 자식 테이블 모두 해당 칼럼 인덱스 생성 필요 & 변경시 부모, 자식 테이블 데이터 있는지 체크 작업 필요하므로 잠금이 려러 테이블로 전파, 그로 인해 데드락 발생할 때 많으므로 개발시 주의!
* 수동 데이터 적재, 스키마 변경 등 관리 작업 실패 가능. 외래키가 복잡하게 얽힌 경우.
	* foreign_key_checks 시스템 변수 OFF 설정시, 외래 키 관계 체크 작업 일시 멈춤.
	* 속도 빨라지나, 부모 삭제시 자식도 삭제해서 일관성 유지 필요.

#### 4.2.3 MVCC(Multi Version Concurrency Control)
* 목적 : 잠금 사용 않는 일관된 읽기 제공.
* 방법 : **언두 로그** 이용해 기능 구현. (하나의 레코드에 대해 여러 버전 동시 관리 & 필요에 따라 보여지는 데이터 달리함.)
	* 언두 로그 : InnoDB 버퍼 풀이나 데이터 파일 있는 내용 대신 변경 이전 내용.
* commit : 현 상태를 영구 데이터화.
* rollback : 언두 영역의 백업 데이터를 InnoDB 버퍼 풀로 복구, 언두 영역 내용 삭제.

#### 4.2.4 잠금 없는 일관된 읽기
* MVCC 기술 이용해 잠금 걸지 않고 읽기 수행.
	* ex. a 사용자가 레코드 변경 후 커밋 전. b 사용자 읽기 작업시 언두 로그 사용.

#### 4.2.5 자동 데드락 감지
* 잠금이 교착 상태 빠지지 않았는지 체크 위해 잠금 대기 목록 그래프로 관리.
* 데드락 감지 스레드가 주기적으로 잠금 대기 그래프 검사해, 교착 상태 빠진 트랜잭션들 찾아 그중 하나 강제 종료.
	* 강제종료 기준 : 언두 로그 양 적은 것.(롤백 해도 언두 처리해야할 양 적다는 것, 부하 적기 때문)
	* InnoDB 스토리지 엔진은 상위 레이어 MySQL 엔진 관리 테이블 잠금은 볼 수 없으나, innodb_table_locks 활성화 하면 가능.
	* 동시 처리 스레드 매우 많으면, 데드락 감지 스레드 동작시 더 느려짐.
	* innodb_lock_wati_timeout 활성화시 데드락 상황 일정 시간 지나면 자동 요청 실패, 에러 메시지 반환. 50초보다 낮게 권장.

#### 4.2.6 자동화된 장애 복구
* MySQL 서버 시작시, 완료되지 못한 트랜잭션, 디스크에 일부만 기록된 데이터 페이지 등에 대한 일련의 복구 작업 자동 실행.
	* 자동 복구될 수 없는 손상 존재시(디스크, 서버 hw 이슈) : MySQL 서버 종료 ➡️ innodb_force_recovery 설정해서 서버 시작하면 InnoDB 스토리지 엔진이 데이터 파일, 로그 파일 손상 여부 검사 과정 선별적 진행 ➡️  서버 기동되고 InnoDB 테이블 인식되면 mysqldump 로 백업해서 테이블 재생성.
* 수동) 백업 이용해 db 새로 구축, 바이너리 로그 사용해 최대한 장애 시점까지의 데이터 복구.
	
#### 4.2.7 InnoDB 버퍼 풀
* 버퍼 풀 : 디스크의 데이터 파일, 인덱스 정보를 메모리에 캐시해 두는 공간
	* 쓰기 작업 지연시켜 일괄 작업으로 처리하는 버퍼 역할. 랜덤한 디스크 작업 횟수 절감.
* 크기 설정 
	* 레코드 버퍼가 상당한 메모리 사용하기도 함 : 각 클라이언트 세션에서 테이블의 레코드 일고 쓸 때 버퍼로 사용하는 공간.
	* innodb_buffer_pool_size 동적으로 버퍼풀 크기 확장. 크리티컬 변경이므로 한가할 때.
* 버퍼 풀 구조
	* 버퍼 풀을 페이지 크기로 쪼개, InnoDB 엔진이 데이터 필요시, 해당 데이터 페이지를 읽어 각 조각에 저장.
	* LRU리스트, 플러시 리스트, 프리 리스트를 관리.
		* 프리 리스트 : InnoDB 버퍼 풀에서 실 사용자 데이터로 채워지지 않은 빈 페이지 목록
		* LRU리스트 : LRU, MRU 결합된 형태. 캐시 역할로 최대한 오래 유지.
		* 플러시 리스트 : 디스크로 동기화되지 않은 데이터 가진 더티 페이지의 변경 시점 기준의 페이지 목록 관리. 
* 버퍼 풀과 리드 로그
	* 버퍼 풀로 인한 db 성능 향상 :  데이터 캐시, 쓰기 버퍼링.
	* 체크 포인트 발생시 체크 포인트 LSN보다 작은 LSN 값 가진 리두 로그 엔트리는 디스크로 동기화.
		* 체크 포인트 : 리두 로그와 버퍼 풀의 InnoDB 버퍼 풀의 더티 페이지를 디스크로 동기화 하는 것. 
		* 활성 리두 로그 : 리두  로그 파일에서 재사용 불가 공간.
		* 활성 리두 공간의 시작점 : 주기적으로 발생시킨 체크포인트 이벤트 중 가장 최근 체크 포인트 지점의 LSN(Log Sequence Number)
* 버퍼 풀 플러시
	* 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지를 디스크 동기화하기 위한 방법 
		* 플러시 리스트 플러시 : 오래된 리두 로그 공간 지워지려면 반드시 더티 페이지가 먼저 디스크로 동기화되야함. 주기적 호출. 
		* LRU 리스트 플러시 : 사용 빈도 낮은 페이지 제거해 새로운 페이지 읽어올 공간 만들 때 사용.
* 버퍼 풀 상태 백업 및 복구
	* 워밍업 : 디스크의 데이터가 버퍼 풀에 적재된 상태. 이로 인해 빠른 쿼리 처리 가능.
	* 서버 셧다운 되기전 버푸 풀의 백업 실행, 서버 실행시자동으로 백업된 버퍼 풀 상태 복구 기능 제공.
* 버퍼 풀 적재 내용 확인

#### 4.2.8 Double Write Buffer
* 더티 페이지를 디스크에 쓰기 전 Double Write Buffer에 기록.
* 데이터 파일 쓰기 실패 시 복구 위한 목적. 무결성이 매우 중요시 활용.

#### 4.2.9 언두 로그
* **언두 로그 : 트랜잭션과 격리 수준 보장 위해 DML로 변경되기 이전 버전의 데이터 별도 백업한 데이터.**
* 트랜잭션 보장 : 트랜잭션 롤백시 복구.
* 격리 수준 보장 : 데이터 변경 중 다른 커넥션에서 데이터 조회시 격리 수준에 맞게 언두 로그 읽어서 반환하기도.
* 활성 상태 트랜잭션 장시간 유지 주의‼️ ➡️ 안정 시점 대비 언두로그 레코드량 모니터링하면 좋음.

* 언두 테이블스페이스 관리
	*  언두 테이블스페이스 : 언두 로그 저장되는 공간. 항상 시스템 테이블스페이스 외부 별도 로그 파일에 기록.
	* 8.0부터 언두 테이블스페이스 동적 추가 삭제 가능.
	* 언두 테이블스페이스 트런케이트 : 불필요한 공간 잘라내는 방법 
	
#### 4.2.10 체인지 버퍼
* 체인지 버퍼 : DML로 인해 변경할 인덱스 페이지 디스크로부터 읽어 업데이트해야할 때 즉시 하지 않고 저장하는, 임시 메모리 공간.
	* 유니크 인덱스는 사용 불가.
	* 체인지 버퍼 머지 스레드 : 백그라운드 스레드에 의해 병합 

#### 4.2.11 리두 로그 및 로그 버퍼
* 리두 로그 
	* 변경 작업 기록한 로그.
	* ACID 중 Durable(영속성)과 밀접한 연관.
	* 서버 비정상 종료시, 데이터 파일에 기록 못한 데이터 잃지 않도록 안전장치.
	* 1. 데이터 변경 내용 로그로 기록. 2. 비정상 종료시 리두로그로 데이터 파일을 서버 종료 전 상태로 복구.
 * 로그 버퍼
	 * 리두 로그 버퍼링에 사용되는 공간.

* 리두 로그 아카이빙
		

## 4.3 MyISAM 스토리지 엔진 아키텍처



## 4.4 MySQL 로그 파일

